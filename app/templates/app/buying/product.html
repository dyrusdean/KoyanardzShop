{% extends 'app/navigation.html' %}
{% load static %}
{% load humanize %}

{% block content %}

<div class="productpage">
    <div class="product-header">
        <div class="product-title">
            <h1>Products</h1>
            <p class="muted">Browse our latest items</p>
        </div>

        <div class="product-controls">
            <form class="search-form" action="{% url 'product' %}" method="GET" id="searchForm">
                <input type="text" name="search" value="{{ search_query }}" placeholder="Search products" aria-label="Search products">
                <input type="hidden" name="category" value="{{ category_filter }}">
                <input type="hidden" name="brand" value="{{ brand_filter }}">
                <input type="hidden" name="price_order" value="{{ price_order }}">
            </form>

            <div class="controls-right">
                <div class="sort-wrapper">
                    <select class="sort-dropdown" id="priceOrder">
                        <option value="">üìä Sort By</option>
                        <option value="most_buy" {% if price_order == 'most_buy' %}selected{% endif %}>‚≠ê Best Seller</option>
                        <option value="newest" {% if price_order == 'newest' %}selected{% endif %}>‚ú® Newest</option>
                        <option value="oldest" {% if price_order == 'oldest' %}selected{% endif %}>üìÖ Oldest</option>
                        <option value="high" {% if price_order == 'high' %}selected{% endif %}>üí∞ Price: High to Low</option>
                        <option value="low" {% if price_order == 'low' %}selected{% endif %}>üíµ Price: Low to High</option>
                    </select>
                </div>
                <button id="filterToggle" class="filter-btn">üîç Filters</button>
            </div>
        </div>
    </div>

    <div class="filter-panel" aria-hidden="true" id="filterPanel">
        <div class="filter-panel-overlay"></div>
        <div class="filter-panel-inner">
            <div class="filter-panel-header">
                <h2 class="filter-panel-title">üîç Filters</h2>
                <button id="filterClose" class="filter-close-btn" aria-label="Close filters" title="Close filters">
                    <span>‚úï</span>
                </button>
            </div>
            
            <form action="{% url 'product' %}" method="GET" class="filter-form" id="mainFilterForm">
                <input type="hidden" name="search" value="{{ search_query }}">
                <input type="hidden" name="price_order" value="{{ price_order }}">
                
                <!-- Category Filter -->
                <div class="filter-section">
                    <div class="filter-section-header">
                        <label class="filter-label">üì¶ Category</label>
                    </div>
                    <select class="filter-select" name="category" id="categorySelect">
                        <option value="">All Categories</option>
                        {% for category in categories %}
                            <option value="{{ category.id }}" {% if category.id|stringformat:'s' == category_filter %}selected{% endif %}>{{ category.category_name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- Brand Filter -->
                <div class="filter-section">
                    <div class="filter-section-header">
                        <label class="filter-label">üè∑Ô∏è Brand</label>
                        <button type="button" class="clear-filter-btn" id="clearBrandFilter" style="display: none;">Clear</button>
                    </div>
                    <div class="brand-list-wrapper">
                        <ul id="brand_filter" class="brand-list">
                            {% for brand in brands %}
                                <li data-id="{{ brand.id }}" class="brand-item {% if brand_filter|stringformat:'s' == brand.id|stringformat:'s' %}selected{% endif %}" role="option">
                                    <input type="checkbox" class="brand-checkbox" value="{{ brand.id }}" {% if brand_filter|stringformat:'s' == brand.id|stringformat:'s' %}checked{% endif %} />
                                    <span class="brand-name">{{ brand.brand|escape }}</span>
                                </li>
                            {% endfor %}
                        </ul>
                    </div>
                </div>

                <!-- Apply Filters Button -->
                <div class="filter-actions">
                    <button type="submit" class="filter-apply-btn">‚úì Apply Filters</button>
                    <button type="reset" class="filter-reset-btn" id="resetFilters">‚Üª Reset All</button>
                </div>
            </form>
        </div>
    </div>

    <main class="products-main">
        <div class="product-grid">
            {% if products %}
                {% for p in products %}
                    <article class="product-card">
                        {% if p.category_name.category_name == '2nd Hand' %}
                            <span class="product-tag tag-secondhand">2nd Hand</span>
                        {% elif p.created_at %}
                            {% now "U" as current_timestamp %}
                            {% with created_timestamp=p.created_at|date:"U" %}
                                {% if current_timestamp|add:"-604800"|add:"0" < created_timestamp|add:"0" %}
                                    <span class="product-tag tag-new">New</span>
                                {% endif %}
                            {% endwith %}
                        {% endif %}
                        {% if p.total_bought and p.total_bought > 0 %}
                            <span class="product-tag tag-bestseller">Best Seller</span>
                        {% endif %}
                        <button class="favorite_btn {% if p.id|stringformat:'s' in favorites %}favorited{% endif %}" data-product-id="{{ p.id }}" aria-label="Add to favorites" type="button" style="position: absolute !important; top: 10px !important; right: 10px !important; z-index: 20 !important; pointer-events: auto !important;">
                            <i class="{% if p.id|stringformat:'s' in favorites %}fa-solid{% else %}fa-regular{% endif %} fa-heart"></i>
                        </button>
                        <a href="{% url 'product_item' p.id %}" class="product-thumb" id="product-thumbs">
                            {% if p.image and p.image.url %}
                                <img src="{{ p.image.url }}" alt="{{ p.product_name }}" loading="lazy">
                            {% else %}
                                <img src="{% static 'images/products/placeholder.png' %}" alt="{{ p.product_name }}" loading="lazy">
                            {% endif %}
                        </a>
                        <div class="card-body">
                            <h3 class="card-title">{{ p.product_name }}</h3>
                            <div class="card-meta">
                                <span class="price">‚Ç±{{ p.price|intcomma }}</span>
                            </div>
                            {% if p.reviews.all %}
                                {% with total_reviews=p.reviews.count %}
                                    <div style="display: flex; align-items: center; gap: 6px; margin: 8px 0;">
                                        <span style="color: #ffc107; font-size: 12px;">
                                            {% for i in "12345" %}
                                                {% if i|add:"0" <= p.reviews.all|length %}‚òÖ{% else %}‚òÜ{% endif %}
                                            {% endfor %}
                                        </span>
                                        <span style="font-size: 11px; color: #666;">({{ total_reviews }})</span>
                                    </div>
                                {% endwith %}
                            {% else %}
                                <div style="display: flex; align-items: center; gap: 6px; margin: 8px 0;">
                                    <span style="color: #ddd; font-size: 12px;">‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ</span>
                                    <span style="font-size: 11px; color: #999;">No reviews</span>
                                </div>
                            {% endif %}
                            <div class="card-actions">
                                <form class="add-cart-form" method="post" action="{% url 'direct_checkout' %}">
                                    {% csrf_token %}
                                    <input type="hidden" name="product_id" value="{{ p.id }}">
                                    <input type="hidden" name="quantity" value="1">
                                    <button type="submit" class="btn-sm" id="product_buynow">Buy Now</button>
                                </form>
                                <button class="add-to-cart-btn" data-product-id="{{ p.id }}" aria-label="Add to cart"><i class="fa-solid fa-shopping-cart"></i></button>
                            </div>
                        </div>
                    </article>
                {% endfor %}
            {% else %}
                <p>No products found.</p>
            {% endif %}
        </div>

        <div style="margin-top:12px"> {% if is_paginated %}
            {% include "app/pagination.html" %}
        {% endif %}</div>
    </main>

</div>

<div id="cart-popup" class="cart-popup">
    <div class="cart-popup-content">
        <span class="cart-popup-message">Added to cart!</span>
    </div>
</div>



<div id="custom-chat-widget" class="custom-chat-widget hidden">
    <div class="custom-chat-header">
        <div class="custom-chat-header-content">
            <h3 class="custom-chat-title">üí¨ Chat Assistant</h3>
            <p class="custom-chat-subtitle">Ask us anything!</p>
        </div>
        <div class="custom-chat-header-actions">
            <button id="custom-chat-clear" class="custom-chat-icon-btn" aria-label="Clear chat" title="Clear chat history"><i class="fa-solid fa-trash"></i></button>
            <button id="custom-chat-minimize" class="custom-chat-icon-btn" aria-label="Minimize">‚àí</button>
            <button id="custom-chat-close" class="custom-chat-icon-btn" aria-label="Close">‚úï</button>
        </div>
    </div>
    <div class="custom-chat-messages" id="custom-chat-messages">
    </div>
    <div class="custom-chat-quick-actions" id="custom-chat-quick-actions" style="display: none; padding: 10px; border-top: 1px solid #e0e0e0;">
        <p style="margin: 0 0 10px 0; font-size: 12px; color: #666; text-align: center;">Quick actions:</p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <button class="custom-chat-quick-btn" data-message="I need product recommendations">üì¶ Product Recommendations</button>
            <button class="custom-chat-quick-btn" data-message="Help me build a computer">üñ•Ô∏è Build Computer</button>
            <button class="custom-chat-quick-btn" data-message="Tell me about your store">üè™ Store Information</button>
            <button class="custom-chat-quick-btn" data-message="I want to schedule an appointment">üìÖ Appointments</button>
        </div>
    </div>
    <div class="custom-chat-input-area">
        <input 
            type="text" 
            id="custom-chat-input" 
            class="custom-chat-input" 
            placeholder="Type your message..."
            aria-label="Type your message"
        >
        <button id="custom-chat-send" class="custom-chat-send-btn" aria-label="Send message">
            <i class="fa-solid fa-paper-plane"></i>
        </button>
    </div>
</div>

<!-- Chat Toggle Button -->
<button id="custom-chat-toggle" class="custom-chat-toggle" aria-label="Open chat">
    ü§ñ
    <span class="custom-chat-badge" id="custom-chat-badge" style="display: none;">1</span>
</button>

<script>
    class GeminiChat {
        constructor() {
            // Get API key from Django template context
            this.apiKey = '{{ gemini_api_key }}' || '';
            
            // Validate API key exists
            if (!this.apiKey || this.apiKey.trim() === '') {
                console.error('‚ö†Ô∏è Gemini API key is missing!');
                this.apiKey = '';
            }
            
            // System prompt will be loaded from server
            this.systemPrompt = '';
            this.storeInfo = null;
            this.conversationHistory = [];
            this.isMinimized = false;
            this.unreadCount = 0;
            this.messagesLoaded = false;
            this.firstMessageShown = false;
            
            // Generate or get unique session ID
            this.sessionId = this.getOrCreateSessionId();
            this.isLoggedIn = '{{ user.is_authenticated }}' === 'True';
            
            // Build Computer State
            this.buildInProgress = false;
            this.selectedComponents = {}; // { category: { id, name, price, image, hasModel } }
            this.componentOrder = ['monitor', 'mouse', 'keyboard', 'headset', 'case', 'storage', 'gpu', 'motherboard', 'ram', 'fan'];
            this.currentComponentIndex = 0;
            
            // Error tracking for debugging
            this.lastError = null;
            this.errorCount = 0;
            this.maxErrors = 5;
            
            try {
                this.loadStoreInfo(); // Load store info first
                this.loadSystemPrompt(); // Load prompt from server on initialization
                this.init();
                this.loadChatHistory();
                
                // Restore build state if one was in progress
                if (this.loadBuildState()) {
                    // Build was in progress, need to restore the UI
                    this.addMessage(`üîß Restoring your build in progress...`, 'bot');
                    setTimeout(() => {
                        this.displayComponentCategories();
                    }, 500);
                }
            } catch (e) {
                console.error('Chat initialization error:', e);
                this.lastError = e.message;
            }
        }

        getOrCreateSessionId() {
            /**
             * Generate unique session ID for this user
             * Logged-in users use email, anonymous users use localStorage UUID
             */
            if ('{{ user.is_authenticated }}' === 'True') {
                // For logged-in users, use email as session key
                return 'user-{{ user.id }}-chat';
            } else {
                // For anonymous users, create/get a unique session ID
                let sessionId = localStorage.getItem('gemini_session_id');
                if (!sessionId) {
                    sessionId = 'anon-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('gemini_session_id', sessionId);
                }
                return sessionId;
            }
        }

        async loadStoreInfo() {
            /**
             * Load store information from database (categories, price range, etc)
             * This ensures AI only knows about real products
             */
            try {
                const response = await fetch('/api/store-info/');
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        this.storeInfo = data;
                        console.log('Store info loaded:', data);
                    } else {
                        console.warn('Store info error:', data.error);
                    }
                } else {
                    const text = await response.text();
                    console.warn('Failed to load store info:', response.status, text);
                }
            } catch (error) {
                console.error('Error loading store info:', error);
            }
        }

        async loadSystemPrompt() {
            /**
             * Load system prompt from Django backend
             * This allows updating AI behavior without redeploying the frontend
             */
            try {
                const response = await fetch('/api/gemini/system-prompt/');
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.prompt) {
                        this.systemPrompt = data.prompt;
                        console.log('System prompt loaded from server');
                    }
                } else {
                    console.warn('Failed to load system prompt from server, using fallback');
                    this.useDefaultSystemPrompt();
                }
            } catch (error) {
                console.error('Error loading system prompt:', error);
                this.useDefaultSystemPrompt();
            }
        }

        useDefaultSystemPrompt() {
            /**
             * Fallback system prompt if server endpoint fails
             */
            this.systemPrompt = `You are a friendly and helpful AI assistant for Koyanardzshop, a computer parts and electronics retail store located at 341 Molino Road, Bacoor, Cavite. Your name is "Koyanardz Assistant".

CRITICAL: ONLY recommend products from these actual categories:
- Laptops
- Desktop Computers
- PC Sets (Pre-assembled desktop computer bundles)
- Monitors
- Motherboards
- Processors (CPUs)
- Graphics Cards (GPUs)
- RAM Memory
- Storage Drives (SSD/HDD)
- Power Supplies
- Computer Cases
- Cooling Solutions
- Keyboards
- Mouse/Pointing Devices
- Cables & Adapters
- Accessories

IMPORTANT: PC SETS INFORMATION
- We sell PC Sets: Pre-assembled desktop computer bundles (complete, ready-to-use systems)
- When user asks about "pre-built computers", "PC bundles", or "computer sets", recommend PC Sets
- PC Sets are ready-to-use, so customers don't need to build their own
- Search term for PC Sets: @SHOW_PRODUCTS_FOR:PC Set

STORE INFO:
- Hours: Monday-Saturday, 9 AM - 6 PM
- Location: 341 Molino Road, Bacoor, Cavite
- Walk-ins welcome!
- NO online payments - all in-person
- Trade-in services available
- 1-month warranty on secondhand items
- No delivery service

SERVICES:
- Browse and book viewing appointments (in-person preferred)
- Trade-in evaluation (bring device + valid ID)
- Device inspection before purchase
- Custom builds and bundles
- PC Sets (pre-assembled desktop computer bundles)
- New and secondhand items
- Repair assessment

KEY POINTS:
- All payments made IN PERSON with cash
- Bring valid ID for trade-ins
- Book appointments through account for faster service
- Call Facebook page for urgent inquiries
- Damaged devices accepted for evaluation
- NEVER write code or Python in chat
- ONLY recommend products from the categories listed above

Always be warm, helpful, and encourage customers to visit in person. Support both English and Filipino responses.`;
        }

        init() {
            this.setupEventListeners();
        }

        loadChatHistory() {
            // Load previous conversation from database for all users (both logged-in and anonymous)
            // Each user has their own separate conversation
            try {
                this.loadFromDatabase();
            } catch (e) {
                console.log('Could not load chat history:', e);
                this.conversationHistory = [];
            }
        }

        async loadFromDatabase() {
            /**
             * Load conversation from database for all users (logged-in and anonymous)
             * Each user has their own separate conversation stored with their session_id
             */
            try {
                const response = await fetch(`/api/chat/load/?session_id=${encodeURIComponent(this.sessionId)}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.found) {
                        this.conversationHistory = data.messages;
                        console.log('Loaded chat history from database with', this.conversationHistory.length, 'messages');
                    }
                }
            } catch (e) {
                console.log('Could not load chat from database:', e);
            }
        }

        saveChatHistory() {
            // Save conversation to database for both logged-in and anonymous users
            // Each user has their own separate conversation
            try {
                this.saveToDatabase();
            } catch (e) {
                console.log('Could not save chat history:', e);
            }
        }

        async saveToDatabase() {
            /**
             * Save conversation to database for all users (logged-in and anonymous)
             * Each user maintains their own separate conversation
             */
            try {
                await fetch('/api/chat/save/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        session_id: this.sessionId,
                        messages: this.conversationHistory
                    })
                });
            } catch (e) {
                console.log('Could not save chat to database:', e);
            }
        }

        getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    cookie = cookie.trim();
                    if (cookie.startsWith(name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        showQuickActions() {
            /**
             * Show quick action buttons when conversation starts
             */
            const quickActionsContainer = document.getElementById('custom-chat-quick-actions');
            if (quickActionsContainer) {
                quickActionsContainer.style.display = 'block';
            }
        }

        hideQuickActions() {
            /**
             * Hide quick action buttons once user starts interacting
             */
            const quickActionsContainer = document.getElementById('custom-chat-quick-actions');
            if (quickActionsContainer) {
                quickActionsContainer.style.display = 'none';
            }
        }

        setupEventListeners() {
            const toggleBtn = document.getElementById('custom-chat-toggle');
            const minimizeBtn = document.getElementById('custom-chat-minimize');
            const closeBtn = document.getElementById('custom-chat-close');
            const clearBtn = document.getElementById('custom-chat-clear');
            const sendBtn = document.getElementById('custom-chat-send');
            const input = document.getElementById('custom-chat-input');
            const quickActionBtns = document.querySelectorAll('.custom-chat-quick-btn');

            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => this.toggleChat());
            }

            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.minimizeChat();
                });
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.closeChat();
                });
            }

            if (clearBtn) {
                clearBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.clearChat();
                });
            }

            if (sendBtn) {
                sendBtn.addEventListener('click', () => this.sendMessage());
            }

            if (input) {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
            }

            // Setup quick action buttons
            quickActionBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const message = btn.dataset.message;
                    
                    // Special handling for "Build Computer" button
                    if (message === 'Help me build a computer') {
                        document.getElementById('custom-chat-input').value = '';
                        this.hideQuickActions();
                        
                        // Always start fresh build - don't auto-load old state
                        this.buildInProgress = true;
                        this.selectedComponents = {};
                        this.currentComponentIndex = 0;
                        
                        // Add user message
                        this.addMessage(message, 'user');
                        this.conversationHistory.push({
                            role: 'user',
                            content: message,
                            timestamp: new Date().getTime()
                        });
                        
                        // Show the build computer intro
                        setTimeout(() => {
                            this.addMessage('üëã Hi! I\'m Koyanardz Assistant. I\'d love to help you build a computer! To give you the best recommendations, could you tell me a bit more about what you\'re looking for?\n\n‚Ä¢ **What will be the primary use for your computer** (e.g., gaming, work, video editing, general use)?\n‚Ä¢ **Do you have an approximate budget in mind?**\n‚Ä¢ **Are you interested in new or secondhand parts**, or a mix of both?\n‚Ä¢ **Do you need help with just the core computer components**, or a full setup including a monitor and peripherals?\n\nWe also offer custom PC builds and can help you inspect components before purchase. Let me know your preferences, and we can start looking at the right parts for you!', 'bot');
                            
                            // After intro, add the component categories
                            setTimeout(() => {
                                this.displayComponentCategories();
                            }, 800);
                        }, 300);
                    } else {
                        // Normal quick action handling
                        document.getElementById('custom-chat-input').value = message;
                        this.sendMessage();
                    }
                    this.hideQuickActions();
                });
            });
        }

        toggleChat() {
            const widget = document.getElementById('custom-chat-widget');
            const toggleBtn = document.getElementById('custom-chat-toggle');
            
            if (widget && toggleBtn) {
                if (widget.classList.contains('hidden')) {
                    widget.classList.remove('hidden');
                    toggleBtn.classList.add('active');
                    toggleBtn.style.display = 'none';
                    this.unreadCount = 0;
                    this.updateBadge();
                    
                    // Load previous chat messages only if this is the first time opening
                    if (!this.messagesLoaded) {
                        const savedMessages = this.loadMessagesFromStorage();
                        this.messagesLoaded = true;
                        
                        // Show AI introduction ONLY if no saved messages exist
                        if (savedMessages === 0 && !this.firstMessageShown) {
                            setTimeout(() => {
                                this.addMessage('üëã Hello! Welcome to **Koyanardzshop**! I\'m your Koyanardz Assistant, here to help you find the perfect computer parts and electronics. Whether you\'re looking for a gaming setup, need device trade-ins, or want to learn about our products, I\'m here to assist! How can I help you today?', 'bot');
                                this.firstMessageShown = true;
                                // Show quick action buttons when starting a new conversation
                                this.showQuickActions();
                            }, 300);
                        } else if (savedMessages > 0) {
                            // Always show quick actions when reopening chat (user hasn't used them yet if they're still there)
                            this.showQuickActions();
                        }
                    } else {
                        // Re-opened chat - show quick actions again
                        this.showQuickActions();
                    }
                    
                    document.getElementById('custom-chat-input')?.focus();
                } else {
                    widget.classList.add('hidden');
                    toggleBtn.classList.remove('active');
                    toggleBtn.style.display = 'flex';
                    // Keep quick actions state - don't change it when closing
                }
            }
        }

        closeChat() {
            const widget = document.getElementById('custom-chat-widget');
            const toggleBtn = document.getElementById('custom-chat-toggle');
            
            if (widget && toggleBtn) {
                widget.classList.add('hidden');
                toggleBtn.classList.remove('active');
                toggleBtn.style.display = 'flex';
                // Keep quick actions state - don't change it when closing
            }
        }

        clearChat() {
            // Clear all messages from the chat and delete from database/localStorage
            const messagesContainer = document.getElementById('custom-chat-messages');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
            // Reset conversation state
            this.conversationHistory = [];
            this.messagesLoaded = false;
            
            // IMPORTANT: Clear build state from sessionStorage
            sessionStorage.removeItem('currentBuildState');
            this.selectedComponents = {};
            this.currentComponentIndex = 0;
            this.buildInProgress = false;

            // FULLY Clear all localStorage entries for this chat
            const keysToRemove = [
                'gemini_chat_history_' + this.sessionId,
                'gemini_chat_messages',
                'gemini_chat_history',
                'currentBuildState'
            ];
            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
            });

            // Delete from database or localStorage based on user status
            if (this.isLoggedIn) {
                // Delete from database for logged-in users
                this.deleteFromDatabase();
            }

            // Add welcome message
            this.addMessage('üëã Hello! Welcome to **Koyanardzshop**! I\'m your Koyanardz Assistant, here to help you find the perfect computer parts and electronics. Whether you\'re looking for a gaming setup, need device trade-ins, or want to learn about our products, I\'m here to assist! How can I help you today?', 'bot');
            
            // Show quick action buttons again after clearing
            this.showQuickActions();

            console.log('Chat history cleared');
        }

        async deleteFromDatabase() {
            /**
             * Delete conversation from database for logged-in users
             */
            try {
                const response = await fetch('/api/chat/delete/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': this.getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        session_id: this.sessionId
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    console.log('Conversation deleted from database:', data.message);
                }
            } catch (e) {
                console.log('Could not delete chat from database:', e);
            }
        }

        minimizeChat() {
            const widget = document.getElementById('custom-chat-widget');
            if (widget) {
                widget.classList.toggle('minimized');
                this.isMinimized = !this.isMinimized;
            }
        }

        async sendMessage() {
            const input = document.getElementById('custom-chat-input');
            
            // Validate input exists and has value
            if (!input) {
                console.error('‚ùå Chat input element not found');
                return;
            }
            
            const userMessage = input?.value?.trim() || '';
            
            // Validate message is not empty
            if (!userMessage || userMessage.length === 0) {
                console.warn('‚ö†Ô∏è Empty message attempted');
                return;
            }
            
            // Prevent excessively long messages
            if (userMessage.length > 2000) {
                this.addMessage('‚ö†Ô∏è Message is too long (max 2000 characters)', 'bot');
                return;
            }
            
            const messageLower = userMessage.toLowerCase();
            
            // Hide quick actions when user sends a message
            this.hideQuickActions();
            
            // Validate API key before proceeding
            if (!this.apiKey || this.apiKey.trim() === '') {
                this.addMessage('üîë Chat service not configured. Please refresh the page.', 'bot');
                console.error('‚ùå API key missing or empty');
                return;
            }
            
            // Validate conversation history is an array
            if (!Array.isArray(this.conversationHistory)) {
                console.error('‚ö†Ô∏è Conversation history is invalid, reinitializing...');
                this.conversationHistory = [];
            }

            // Check if user wants to build a PC BEFORE sending to AI (natural language detection)
            // Two categories: direct build requests vs. build questions about the feature
            
            // Direct build triggers - user explicitly wants to start building
            const directBuildTriggers = [
                /\byes\b/i,  // User saying "yes" to activation
                /\bok\b/i,   // User saying "ok" to activation
                /\bactivate\b/i,  // User saying "activate it"
                /build.*pc/i,
                /build.*computer/i,
                /help.*build/i,
                /custom.*pc/i,
                /custom.*build/i,
                /want.*build/i,
                /create.*pc/i,
                /assemble.*pc/i,
                /start.*building/i,
                /let.*me.*build/i
            ];
            
            // Build feature questions - user asking about the build process
            const buildQuestionTriggers = [
                /what.*question.*build/i,
                /what.*do.*you.*ask.*build/i,
                /how.*do.*i.*start.*build/i,
                /what.*does.*build.*ask/i,
                /explain.*build.*feature/i,
                /how.*does.*build.*work/i,
                /what.*happen.*build/i
            ];
            
            const isDirect = directBuildTriggers.some(regex => regex.test(messageLower));
            const isQuestion = buildQuestionTriggers.some(regex => regex.test(messageLower));
            const shouldTriggerBuildDirectly = isDirect && !this.buildInProgress;
            const shouldOfferBuildFeature = isQuestion && !this.buildInProgress;
            
            // Handle direct build trigger
            if (shouldTriggerBuildDirectly) {
                // Display user message
                this.addMessage(userMessage, 'user');
                this.conversationHistory.push({
                    role: 'user',
                    content: userMessage,
                    timestamp: new Date().getTime()
                });
                input.value = '';
                
                // Trigger build computer mode immediately
                this.buildInProgress = true;
                this.selectedComponents = {};
                this.currentComponentIndex = 0;
                
                // Show the build computer intro
                setTimeout(() => {
                    this.addMessage('üëã Perfect! I\'d love to help you build a computer! Let me ask you a few questions first:\n\n‚Ä¢ **What will be the primary use** (gaming, work, video editing, general use)?\n‚Ä¢ **Do you have an approximate budget?**\n‚Ä¢ **New or secondhand parts**, or a mix?\n‚Ä¢ **Full setup** (monitor + peripherals) or just core components?\n\nWe offer custom PC builds and component inspection. Let me know, and we\'ll find the perfect parts for you!', 'bot');
                    
                    // After intro, start component selection
                    setTimeout(() => {
                        this.displayComponentCategories();
                    }, 800);
                }, 300);
                
                return;
            }
            
            // Handle build feature question - offer to activate
            if (shouldOfferBuildFeature) {
                // Display user message
                this.addMessage(userMessage, 'user');
                this.conversationHistory.push({
                    role: 'user',
                    content: userMessage,
                    timestamp: new Date().getTime()
                });
                input.value = '';
                
                // Offer to activate the build feature
                setTimeout(() => {
                    this.addMessage('üéØ Would you like to activate the **Build a PC** feature? It will guide you through selecting components step-by-step. Just say yes to get started!', 'bot');
                }, 300);
                
                return;
            }
            
            // Display user message
            this.addMessage(userMessage, 'user');
            this.conversationHistory.push({
                role: 'user',
                content: userMessage,
                timestamp: new Date().getTime()
            });
            input.value = '';

            // DURING BUILD MODE: Check if user is trying to select a product, view 3D, browse category, or skip
            if (this.buildInProgress) {
                const messageLowerForBuild = userMessage.toLowerCase();
                
                // 1. CHECK FOR SKIP COMPONENT COMMANDS: "skip", "skip this", "next", "no", "don't want"
                const skipTriggers = [
                    /\bskip\b/i,
                    /\bskip this\b/i,
                    /\bno\b/i,
                    /\bdon't want\b/i,
                    /\bdont want\b/i,
                    /\bno thanks\b/i,
                    /\bpass\b/i
                ];
                
                const isSkipRequest = skipTriggers.some(regex => regex.test(messageLowerForBuild));
                
                // 2. CHECK FOR BROWSE/BROWSE COMPONENT COMMANDS: "browse", "show me", "what's available", "yes", "let's browse"
                const browseTriggers = [
                    /\bbrowse\b/i,
                    /\bnext\b/i,
                    /\bshow me\b/i,
                    /\bwhat.*available/i,
                    /\byeah\b/i,
                    /\byes\b/i,
                    /\byeah let's\b/i,
                    /\blet's browse\b/i,
                    /\blet me browse\b/i,
                    /\bwhat do you have\b/i,
                    /\bshow options\b/i
                ];
                
                const isBrowseRequest = browseTriggers.some(regex => regex.test(messageLowerForBuild));
                
                // 3. CHECK FOR 3D VIEW COMMANDS: "3d", "show 3d", "view 3d", etc.
                const view3DTriggers = [
                    /\b3d\b/i,
                    /\bshow 3d\b/i,
                    /\bview 3d\b/i,
                    /\bdisplay 3d\b/i,
                    /\b3d model\b/i,
                    /\bview.*model\b/i,
                    /\bshow.*model\b/i
                ];
                
                const is3DRequest = view3DTriggers.some(regex => regex.test(messageLowerForBuild));
                
                // 4. CHECK FOR SELECT COMMANDS: "select", "choose", "pick", "want this", etc.
                const selectTriggers = [
                    /\bselect\b/i,
                    /\bchoose\b/i,
                    /\bpick\b/i,
                    /\bi'll take/i,
                    /\bwant this\b/i,
                    /\bgo with\b/i,
                    /\bthis one\b/i,
                    /\bproceed\b/i
                ];
                
                const isSelectRequest = selectTriggers.some(regex => regex.test(messageLowerForBuild));
                
                // Priority: Check for browse/skip category buttons FIRST (they're shown when selecting components to browse)
                if (isSkipRequest || isBrowseRequest) {
                    // Look for Skip/Browse category buttons
                    const skipBtn = document.querySelector('.skip-component-btn');
                    const browseBtn = document.querySelector('.browse-component-btn');
                    
                    if (isSkipRequest && skipBtn) {
                        console.log(`‚úÖ Automatically clicking SKIP for user command: ${userMessage}`);
                        setTimeout(() => {
                            skipBtn.click();
                        }, 300);
                        return;
                    }
                    
                    if (isBrowseRequest && browseBtn) {
                        console.log(`‚úÖ Automatically clicking BROWSE for user command: ${userMessage}`);
                        setTimeout(() => {
                            browseBtn.click();
                        }, 300);
                        return;
                    }
                }
                
                // Secondary: Check for product selection/3D (when product carousel is displayed)
                if (is3DRequest || isSelectRequest) {
                    // Try to match a product from currently displayed carousel
                    const currentProducts = Array.from(document.querySelectorAll('.product-card-build'));
                    
                    if (currentProducts.length > 0) {
                        let targetButton = null;
                        let buttonType = null; // 'select' or '3d'
                        
                        // Extract potential product name or index from user message
                        // For "select keyboard", match against product names
                        // For just "select", try first product
                        // For "3d", try first product with 3D
                        
                        if (userMessage.length > 10) {
                            // User mentioned something specific, try to match product name
                            const productCards = currentProducts;
                            for (let card of productCards) {
                                const productName = card.querySelector('.product-name')?.textContent?.toLowerCase() || '';
                                const searchWords = messageLowerForBuild.split(/\s+/);
                                
                                // Check if any search words match the product name
                                const matchCount = searchWords.filter(word => 
                                    productName.includes(word) && word.length > 2
                                ).length;
                                
                                if (matchCount > 0) {
                                    // Found a matching product
                                    if (is3DRequest) {
                                        targetButton = card.querySelector('.product-3d-ask-btn');
                                        buttonType = '3d';
                                    } else {
                                        targetButton = card.querySelector('.product-select-btn');
                                        buttonType = 'select';
                                    }
                                    
                                    if (targetButton) break;
                                }
                            }
                        }
                        
                        // Fallback: if no specific product matched, try first available button of requested type
                        if (!targetButton) {
                            if (is3DRequest) {
                                targetButton = currentProducts[0]?.querySelector('.product-3d-ask-btn');
                                buttonType = '3d';
                            } else if (isSelectRequest) {
                                targetButton = currentProducts[0]?.querySelector('.product-select-btn');
                                buttonType = 'select';
                            }
                        }
                        
                        // Click the matched button
                        if (targetButton) {
                            console.log(`‚úÖ Automatically ${buttonType} button for user command: ${userMessage}`);
                            setTimeout(() => {
                                targetButton.click();
                            }, 300);
                            return;
                        }
                    }
                }
            }

            // Show typing indicator
            this.showTypingIndicator();

            // Send to Gemini API
            try {
                // Validate system prompt is loaded
                if (!this.systemPrompt || this.systemPrompt.trim().length === 0) {
                    throw new Error('System prompt not initialized');
                }
                
                // Use models with billing enabled (1000 req/min, pay per token)
                // gemini-2.5-flash: better quality responses (primary)
                // gemini-2.0-flash: fast fallback
                const models = ['gemini-2.5-flash', 'gemini-2.0-flash'];
                let response = null;
                let lastError = null;
                
                for (const modelName of models) {
                    try {
                        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${this.apiKey}`;
                        
                        console.log(`Trying ${modelName}...`);
                        
                        // Validate conversation history before sending
                        const validHistory = this.conversationHistory.filter(msg => {
                            return msg && 
                                   msg.role && 
                                   msg.content && 
                                   typeof msg.content === 'string' &&
                                   msg.content.trim().length > 0;
                        });
                        
                        // Validate we have valid messages
                        if (validHistory.length === 0) {
                            throw new Error('No valid messages in conversation history');
                        }
                        
                        const requestBody = {
                            systemInstruction: {
                                parts: [{ text: this.systemPrompt }]
                            },
                            contents: validHistory.map(msg => ({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: [{ text: String(msg.content).substring(0, 4000) }] // Limit message size
                            })),
                            tools: [
                                {
                                    googleSearch: {}
                                }
                            ]
                        };
                        
                        response = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestBody),
                            signal: AbortSignal.timeout(30000) // 30 second timeout
                        });
                        
                        if (response.ok) {
                            console.log(`‚úÖ Success with ${modelName}`);
                            break;
                        } else {
                            lastError = `${modelName} failed with status ${response.status}`;
                            console.log(lastError);
                        }
                    } catch (e) {
                        lastError = e.message;
                        console.error(`Error trying ${modelName}:`, e);
                    }
                }

                this.hideTypingIndicator();

                // Validate we got a response
                if (!response) {
                    console.error('‚ùå All models failed to respond');
                    this.addMessage('‚ö†Ô∏è AI service unavailable. Please try again in a moment.', 'bot');
                    this.errorCount++;
                    this.lastError = lastError || 'No response from any model';
                    return;
                }

                // Validate response status
                if (!response.ok) {
                    this.errorCount++;
                    
                    // Handle specific HTTP errors
                    if (response.status === 429) {
                        this.addMessage('‚è≥ Too many requests. Please wait a moment before trying again.', 'bot');
                        this.lastError = 'Rate limited';
                    } else if (response.status === 401) {
                        this.addMessage('üîë Authentication error. Please refresh the page.', 'bot');
                        this.lastError = 'Invalid API key';
                    } else if (response.status === 500) {
                        this.addMessage('üîß AI service error. Please try again in a moment.', 'bot');
                        this.lastError = 'Server error';
                    } else {
                        this.addMessage('‚ö†Ô∏è Service error. Please try again.', 'bot');
                        this.lastError = `HTTP ${response.status}`;
                    }
                    
                    try {
                        const errorData = await response.json();
                        console.error('API error response:', errorData);
                    } catch (e) {
                        console.error('Could not parse error response');
                    }
                    return;
                }

                // Parse response
                let data;
                try {
                    data = await response.json();
                } catch (e) {
                    console.error('‚ùå Failed to parse response JSON:', e);
                    this.addMessage('Invalid response format. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                console.log('Gemini response:', data);
                
                // Validate response structure
                if (!data || typeof data !== 'object') {
                    console.error('‚ùå Invalid response type:', typeof data);
                    this.addMessage('Unexpected response format. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                // Check for API errors in response
                if (data.error) {
                    console.error('API returned error:', data.error);
                    this.addMessage(`‚ö†Ô∏è ${data.error.message || 'An error occurred'}`, 'bot');
                    this.errorCount++;
                    this.lastError = data.error.message;
                    return;
                }

                // Validate candidates array exists and has content
                if (!data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
                    console.error('‚ùå No candidates in response');
                    console.error('Response keys:', Object.keys(data));
                    this.addMessage('No response content. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                // Check if we have usageMetadata but no candidates content (API quirk)
                if (data.usageMetadata && (!data.candidates[0].content || !data.candidates[0].content.parts || data.candidates[0].content.parts.length === 0)) {
                    console.warn('‚ö†Ô∏è API returned metadata but empty content - possible API quirk');
                    console.log('Attempting recovery by checking for finishReason...');
                    
                    // Check finish reason to understand why response is empty
                    const finishReason = data.candidates[0]?.finishReason;
                    console.log('Finish reason:', finishReason);
                    
                    if (finishReason === 'SAFETY') {
                        this.addMessage('‚ö†Ô∏è Your message was flagged by our safety filters. Please rephrase and try again.', 'bot');
                    } else if (finishReason === 'MAX_TOKENS') {
                        this.addMessage('Response was too long. Please try a shorter question.', 'bot');
                    } else {
                        this.addMessage('AI service returned empty content. Please try again.', 'bot');
                    }
                    
                    this.errorCount++;
                    return;
                }

                const candidate = data.candidates[0];
                if (!candidate || !candidate.content) {
                    console.error('‚ùå Candidate or content missing:', {
                        hasCandidate: !!candidate,
                        hasContent: candidate?.content ? true : false,
                        candidateKeys: candidate ? Object.keys(candidate) : [],
                        fullCandidate: candidate
                    });
                    this.addMessage('Empty response. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                // Check if content has parts
                if (!candidate.content.parts) {
                    console.error('‚ùå Content.parts is missing or undefined:', {
                        contentKeys: Object.keys(candidate.content),
                        fullContent: candidate.content
                    });
                    this.addMessage('Invalid response structure. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                if (!Array.isArray(candidate.content.parts)) {
                    console.error('‚ùå Content.parts is not an array:', typeof candidate.content.parts);
                    this.addMessage('Invalid response format. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                if (candidate.content.parts.length === 0) {
                    console.error('‚ùå Content.parts is empty array');
                    console.log('Full response for debugging:', JSON.stringify(data, null, 2));
                    
                    // Try to extract any text from alternative locations
                    if (candidate.content.text) {
                        console.log('‚úÖ Found text in candidate.content.text (alternate location)');
                        const botResponse = candidate.content.text;
                        
                        if (botResponse && typeof botResponse === 'string' && botResponse.trim().length > 0) {
                            this.addMessage(botResponse, 'bot');
                            this.conversationHistory.push({
                                role: 'assistant',
                                content: botResponse,
                                timestamp: new Date().getTime()
                            });
                            this.saveChatHistory();
                            this.errorCount = 0;
                            return;
                        }
                    }
                    
                    this.addMessage('No response content available. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }

                const botResponse = candidate.content.parts[0]?.text;
                
                // Validate response text
                if (!botResponse || typeof botResponse !== 'string' || botResponse.trim().length === 0) {
                    console.error('‚ùå Invalid or empty response text:', {
                        hasText: !!botResponse,
                        type: typeof botResponse,
                        length: botResponse?.length,
                        parts: candidate.content.parts
                    });
                    this.addMessage('Empty response from AI. Please try again.', 'bot');
                    this.errorCount++;
                    return;
                }
                
                // Check if response contains product carousel trigger
                if (botResponse.includes('@SHOW_PRODUCTS_FOR:')) {
                    // Extract product search parameters
                    const match = botResponse.match(/@SHOW_PRODUCTS_FOR:([^\n]+)/);
                    if (match && match[1]) {
                        const searchParams = match[1].trim();
                        
                        // Validate search params
                        if (!searchParams || searchParams.length === 0) {
                            console.error('‚ùå Empty search params');
                            this.addMessage('Unable to process product search.', 'bot');
                            return;
                        }
                        
                        // Extract text before the trigger
                        const textBefore = botResponse.split('@SHOW_PRODUCTS_FOR:')[0].trim();
                        
                        // Display text response if any
                        if (textBefore && textBefore.length > 0) {
                            this.addMessage(textBefore, 'bot');
                        }
                        
                        // Parse search parameters
                        const params = new URLSearchParams();
                        const parts = searchParams.split(',');
                        
                        // First part is the query
                        if (parts[0] && parts[0].trim()) {
                            params.append('query', parts[0].trim());
                        }
                        
                        // Additional parameters like max_price:50000
                        for (let i = 1; i < parts.length; i++) {
                            const param = parts[i].split(':');
                            if (param.length === 2 && param[0] && param[1]) {
                                params.append(param[0].trim(), param[1].trim());
                            }
                        }
                        
                        // Fetch and display products
                        this.searchAndDisplayProducts(params.toString());
                    }
                } else {
                    // Regular text response - display as is
                    this.addMessage(botResponse, 'bot');
                }
                
                // Add to conversation history
                this.conversationHistory.push({
                    role: 'assistant',
                    content: botResponse,
                    timestamp: new Date().getTime()
                });
                
                // Save conversation
                this.saveChatHistory();
                
                // Reset error count on success
                this.errorCount = 0;
                
            } catch (error) {
                console.error('‚ùå Error in sendMessage:', error);
                this.hideTypingIndicator();
                
                this.lastError = error.message;
                this.errorCount++;
                
                // Different messages for different error types
                if (error.name === 'AbortError') {
                    this.addMessage('‚è±Ô∏è Request timed out. Please check your internet connection.', 'bot');
                } else if (error.message.includes('Network')) {
                    this.addMessage('üåê Network error. Please check your internet connection.', 'bot');
                } else if (error.message.includes('System prompt')) {
                    this.addMessage('‚öôÔ∏è Chat service not fully initialized. Please refresh the page.', 'bot');
                } else {
                    this.addMessage('‚ùå An error occurred. Please try again.', 'bot');
                }
                
                // Log detailed error for debugging
                if (this.errorCount > this.maxErrors) {
                    console.error('‚õî Too many errors, stopping chat:', this.lastError);
                }
            }
        }

        displayComponentCategories() {
            /**
             * Display the NEXT component category button for Build Computer feature
             * Only show one component at a time in sequence
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) {
                console.error('‚ùå Chat messages container not found');
                return;
            }

            // Validate component order exists
            if (!Array.isArray(this.componentOrder)) {
                console.error('‚ùå Component order not initialized');
                return;
            }

            // Get the current component in the order
            if (this.currentComponentIndex >= this.componentOrder.length) {
                // All components done
                setTimeout(() => {
                    this.showBuildSummary();
                }, 500);
                return;
            }

            const currentComponentId = this.componentOrder[this.currentComponentIndex];
            
            if (!currentComponentId || typeof currentComponentId !== 'string') {
                console.error('‚ùå Invalid component ID:', currentComponentId);
                return;
            }
            
            const categories = [
                { id: 'monitor', name: 'üñ•Ô∏è Monitor', label: 'Monitor' },
                { id: 'mouse', name: 'üñ±Ô∏è Mouse', label: 'Mouse' },
                { id: 'keyboard', name: '‚å®Ô∏è Keyboard', label: 'Keyboard' },
                { id: 'headset', name: 'üéß Headset', label: 'Headset' },
                { id: 'case', name: 'üì¶ PC Case', label: 'Case' },
                { id: 'storage', name: 'üíæ Storage', label: 'Storage' },
                { id: 'gpu', name: 'üéÆ Graphics Card (GPU)', label: 'Graphics Card' },
                { id: 'motherboard', name: 'üîå Motherboard', label: 'Motherboard' },
                { id: 'ram', name: '‚ö° RAM', label: 'RAM' },
                { id: 'fan', name: '‚ùÑÔ∏è Cooling Fan', label: 'Cooling Fan' }
            ];

            // Find the current category
            const currentCategory = categories.find(cat => cat.id === currentComponentId);
            if (!currentCategory) {
                console.error('‚ùå Category not found:', currentComponentId);
                return;
            }

            // Check if already selected (skip if yes)
            if (this.selectedComponents && this.selectedComponents[currentComponentId]) {
                // Already selected, move to next
                this.currentComponentIndex++;
                this.displayComponentCategories();
                return;
            }

            const categoryDiv = document.createElement('div');
            if (!categoryDiv) {
                console.error('‚ùå Failed to create category div');
                return;
            }

            categoryDiv.className = 'custom-chat-message bot-message';
            categoryDiv.innerHTML = `
                <div class="custom-chat-bubble" style="max-width: 100%; padding: 16px;">
                    <p style="margin: 0 0 12px 0; font-weight: 600; color: #333;">Which ${currentCategory.label} would you like?</p>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="skip-component-btn" data-category="${currentCategory.id}" data-label="${currentCategory.label}" style="padding: 10px 12px; background: #e8f0ff; border: 2px solid #667eea; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; color: #667eea; transition: all 0.3s;">
                            ‚è≠Ô∏è Skip ${currentCategory.label}
                        </button>
                        <button class="browse-component-btn" data-category="${currentCategory.id}" data-label="${currentCategory.label}" style="padding: 10px 12px; background: #667eea; border: 2px solid #667eea; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; color: white; transition: all 0.3s;">
                            üîç Browse ${currentCategory.label}
                        </button>
                    </div>
                </div>
            `;

            container.appendChild(categoryDiv);
            container.scrollTop = container.scrollHeight;

            // Add event listeners with error handling
            const browseButtons = categoryDiv.querySelectorAll('.browse-component-btn');
            if (browseButtons && browseButtons.length > 0) {
                browseButtons.forEach(btn => {
                    if (!btn) return;
                    btn.addEventListener('click', (e) => {
                        try {
                            const category = btn.dataset.category;
                            const label = btn.dataset.label;
                            
                            if (!category || !label) {
                                console.error('‚ùå Missing category or label data');
                                return;
                            }
                            
                            this.handleCategorySelection(category, label);
                        } catch (error) {
                            console.error('‚ùå Error handling category selection:', error);
                            this.addMessage('An error occurred. Please try again.', 'bot');
                        }
                    });
                });
            }

            const skipButtons = categoryDiv.querySelectorAll('.skip-component-btn');
            if (skipButtons && skipButtons.length > 0) {
                skipButtons.forEach(btn => {
                    if (!btn) return;
                    btn.addEventListener('click', (e) => {
                        try {
                            const label = btn.dataset.label;
                            if (!label) {
                                console.error('‚ùå Missing label for skip button');
                                return;
                            }
                            
                            this.addMessage(`Skipping ${label}`, 'user');
                            this.currentComponentIndex++;
                            this.saveBuildState();
                            setTimeout(() => {
                                this.displayComponentCategories();
                            }, 500);
                        } catch (error) {
                            console.error('‚ùå Error skipping component:', error);
                            this.addMessage('An error occurred. Please try again.', 'bot');
                        }
                    });
                });
            }
        }

        async handleCategorySelection(category, label) {
            /**
             * Handle when user selects a component category
             * Only search by component_type category, not by description
             */
            // Add user selection message
            this.addMessage(`Show me ${label}${label.endsWith('s') || label === 'RAM' ? '' : 's'}`, 'user');
            
            // Show loading indicator
            this.showTypingIndicator();

            try {
                // Map labels to search terms that work with backend
                const searchTerms = {
                    'Monitor': 'monitor',
                    'Mouse': 'mouse',
                    'Keyboard': 'keyboard',
                    'Headset': 'headset',
                    'Case': 'case',
                    'Storage': 'storage',
                    'Graphics Card': 'gpu',
                    'Motherboard': 'motherboard',
                    'RAM': 'ram',
                    'Cooling Fan': 'cooling'
                };
                
                const searchTerm = searchTerms[label] || label;
                
                // Search for products in this category - use ONLY category filter, no description search
                const url = `/api/products/recommend/?category=${encodeURIComponent(searchTerm)}&max_results=12`;
                const response = await fetch(url);

                this.hideTypingIndicator();

                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.products && data.products.length > 0) {
                        // Display products with 3D model preview
                        this.displayProductsWithModels(data.products, label, category);
                        
                        // Add followup question only if NOT in build mode
                        if (!this.buildInProgress) {
                            setTimeout(() => {
                                this.addMessage(`Great! Here are the ${label}s we have available. Click on any product to see details or view 3D models if available. Would you like to see another component?`, 'bot');
                            }, 500);
                        }
                    } else {
                        this.addMessage(`Sorry, we don't have ${label}s available right now. Let's move to the next component.`, 'bot');
                        // Auto move to next if no products found
                        setTimeout(() => {
                            this.moveToNextComponent();
                        }, 1500);
                    }
                } else {
                    this.addMessage(`Sorry, we couldn't load ${label}s right now. Let's move to the next component.`, 'bot');
                    setTimeout(() => {
                        this.moveToNextComponent();
                    }, 1500);
                }
            } catch (error) {
                this.hideTypingIndicator();
                console.error('Error fetching products:', error);
                this.addMessage('Error loading products. Please try again.', 'bot');
            }
        }

        displayProductsWithModels(products, categoryLabel, categoryId) {
            /**
             * Display products in a grid with 3D model previews
             * If in build mode, add "Select" buttons instead of "Details"
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container || !products) return;

            const productsDiv = document.createElement('div');
            productsDiv.className = 'custom-chat-message bot-message';
            const productsHtml = `
                <div class="custom-chat-bubble product-carousel-bubble" style="max-width: 100%;">
                    <p class="carousel-title">${categoryLabel} - Available Options</p>
                    <div class="product-carousel" style="display: flex; gap: 12px; overflow-x: auto; padding: 8px 0; pointer-events: auto; touch-action: auto;">
                        ${products.map(product => `
                            <div class="product-card-build" data-product-id="${product.id}" style="cursor: pointer; flex: 0 0 160px; background: white; border-radius: 6px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); pointer-events: auto; touch-action: auto;">
                                <div class="product-image" style="width: 100%; height: 120px; background: #f0f0f0; overflow: hidden; pointer-events: none;">
                                    <img src="${product.image_url || '/static/images/placeholder.png'}" alt="${product.name}" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;">
                                </div>
                                <div class="product-info" style="padding: 8px; pointer-events: auto;">
                                    <h4 class="product-name" style="margin: 0 0 2px 0; font-size: 12px; font-weight: 600; color: #333; line-height: 1.2; pointer-events: none;">${product.name.substring(0, 35)}</h4>
                                    <p class="product-price" style="margin: 0 0 6px 0; font-size: 13px; font-weight: 700; color: #667eea; pointer-events: none;">‚Ç±${parseFloat(product.price).toLocaleString('en-PH')}</p>
                                    <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                                        ${this.buildInProgress ? 
                                            `<button class="product-select-btn" data-product-id="${product.id}" data-category="${categoryId}" type="button" style="flex: 1; padding: 4px 6px; background: #28a745; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer; font-weight: 600; pointer-events: auto !important; touch-action: auto; -webkit-user-select: none; user-select: none; z-index: 10 !important; position: relative;">Select</button>` :
                                            `<button class="product-details-btn" data-product-id="${product.id}" type="button" style="flex: 1; padding: 4px 6px; background: #667eea; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer; pointer-events: auto !important; touch-action: auto; -webkit-user-select: none; user-select: none; z-index: 10 !important; position: relative;">Details</button>`
                                        }
                                        ${product.model_3d ? `<button class="product-3d-ask-btn" data-product-id="${product.id}" data-product-name="${product.name}" data-model-url="${product.model_3d}" type="button" style="flex: 1; padding: 4px 6px; background: #764ba2; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer; pointer-events: auto !important; touch-action: auto; -webkit-user-select: none; user-select: none; z-index: 10 !important; position: relative;">3D?</button>` : ''}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            productsDiv.innerHTML = productsHtml;

            container.appendChild(productsDiv);
            container.scrollTop = container.scrollHeight;

            // Save carousel HTML to localStorage for persistence
            this.saveChatMessage(productsHtml, 'bot', true);

            // Store products in a map for quick lookup by ID
            const productsMap = new Map(products.map(p => [String(p.id), p]));

            // Add event listeners directly to the newly created buttons using the stable container
            const selectBtns = productsDiv.querySelectorAll('.product-select-btn');
            selectBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    const productId = btn.dataset.productId;
                    const category = btn.dataset.category;
                    const product = productsMap.get(String(productId));
                    if (product) {
                        this.selectComponent(category, product);
                    }
                });
            });

            // Details buttons (when not in build mode)
            const detailsBtns = productsDiv.querySelectorAll('.product-details-btn');
            detailsBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    const productId = btn.dataset.productId;
                    const product = productsMap.get(String(productId));
                    if (product) {
                        this.addMessage(`üì¶ ${product.name} - ‚Ç±${parseFloat(product.price).toLocaleString('en-PH')}\n\nWould you like to add this to your cart?`, 'bot');
                    }
                });
            });

            // 3D Model Ask buttons
            const ask3DBtns = productsDiv.querySelectorAll('.product-3d-ask-btn');
            ask3DBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    const productId = btn.dataset.productId;
                    const modelUrl = btn.dataset.modelUrl;
                    const product = productsMap.get(String(productId));
                    
                    if (product) {
                        this.askForModel3DView(product, modelUrl);
                    }
                });
            });
        }

        askForModel3DView(product, modelUrl) {
            /**
             * Show the 3D model for viewing ONLY
             * Does NOT advance to next component
             * User must explicitly Select or Skip component to proceed
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const askDiv = document.createElement('div');
            askDiv.className = 'custom-chat-message bot-message';
            askDiv.innerHTML = `
                <div class="custom-chat-bubble" style="max-width: 100%; padding: 10px;">
                    <p style="margin: 0 0 10px 0; font-size: 13px; color: #333;">Viewing 3D model of <strong>${product.name}</strong></p>
                    <div style="display: flex; gap: 8px;">
                        <button class="close-3d-btn" style="flex: 1; padding: 6px 10px; background: #667eea; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">Close 3D View</button>
                    </div>
                </div>
            `;

            container.appendChild(askDiv);
            container.scrollTop = container.scrollHeight;

            // Show the 3D model
            this.show3DModelInChat(modelUrl, product.name);

            // Close button - just remove the 3D view, don't proceed
            askDiv.querySelector('.close-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                askDiv.remove();
                // User must go back and select or skip the component
                // Don't proceed to next component
            });
        }

        selectComponent(category, product) {
            /**
             * User selects a component during build
             * Remember the selection and move to next component
             */
            this.selectedComponents[category] = {
                id: product.id,
                name: product.name,
                price: product.price,
                image_url: product.image_url,
                model_3d: product.model_3d
            };
            this.saveBuildState();

            // Confirm selection
            this.addMessage(`‚úÖ Selected: ${product.name}\nüí∞ Price: ‚Ç±${parseFloat(product.price).toLocaleString('en-PH')}`, 'bot');

            // Move to next component
            setTimeout(() => {
                this.moveToNextComponent();
            }, 500);
        }

        moveToNextComponent() {
            /**
             * Move to the next component in the build process
             * Skip components that are already selected
             */
            this.currentComponentIndex++;
            this.saveBuildState();

            // Show next component or finish
            setTimeout(() => {
                this.displayComponentCategories();
            }, 500);
        }

        showComponentOptions(categoryId, categoryName) {
            /**
             * Show options to browse components or skip
             */
            const categoryNames = {
                'monitor': 'Monitor',
                'mouse': 'Mouse',
                'keyboard': 'Keyboard',
                'headset': 'Headset',
                'case': 'PC Case',
                'storage': 'Storage',
                'gpu': 'Graphics Card',
                'motherboard': 'Motherboard',
                'ram': 'RAM',
                'fan': 'Cooling Fan'
            };

            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'custom-chat-message bot-message';
            optionsDiv.innerHTML = `
                <div class="custom-chat-bubble" style="max-width: 100%; padding: 10px;">
                    <div style="display: flex; gap: 8px;">
                        <button class="browse-component-btn" data-category="${categoryId}" style="flex: 1; padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">Browse ${categoryName}</button>
                        <button class="skip-component-btn" style="flex: 1; padding: 8px 12px; background: #999; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">Skip This</button>
                    </div>
                </div>
            `;

            container.appendChild(optionsDiv);
            container.scrollTop = container.scrollHeight;

            // Browse button
            optionsDiv.querySelector('.browse-component-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                const category = e.target.dataset.category;
                const categoryNameForSearch = categoryNames[category];
                optionsDiv.remove();
                
                // Fetch and display products
                this.showTypingIndicator();
                const url = `/api/products/recommend/?query=${encodeURIComponent(categoryNameForSearch)}&max_results=8`;
                
                try {
                    const response = await fetch(url);
                    this.hideTypingIndicator();
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.products && data.products.length > 0) {
                            this.displayProductsWithModels(data.products, categoryNameForSearch, category);
                        } else {
                            this.addMessage(`Sorry, we don't have ${categoryNameForSearch}s available right now. Let's move to the next component.`, 'bot');
                            setTimeout(() => this.moveToNextComponent(), 800);
                        }
                    }
                } catch (error) {
                    this.hideTypingIndicator();
                    console.error('Error fetching products:', error);
                }
            });

            // Skip button
            optionsDiv.querySelector('.skip-component-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                optionsDiv.remove();
                this.addMessage(`‚è≠Ô∏è Skipping this component. Moving on...`, 'bot');
                setTimeout(() => this.moveToNextComponent(), 500);
            });
        }

        showBuildSummary() {
            /**
             * Show summary of all selected components in a carousel
             * Offer option to view 3D canvas
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            // Check if any components were selected
            const selectedCount = Object.keys(this.selectedComponents).length;
            if (selectedCount === 0) {
                this.addMessage('You didn\'t select any components. Let\'s start fresh!', 'bot');
                this.resetBuild();
                return;
            }

            // Create summary message
            this.addMessage('üéâ **Your Custom Build Summary**', 'bot');

            // Show components in carousel
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'custom-chat-message bot-message';
            summaryDiv.innerHTML = `
                <div class="custom-chat-bubble product-carousel-bubble" style="max-width: 100%;">
                    <p class="carousel-title">Selected Components (${selectedCount} items)</p>
                    <div class="product-carousel" style="display: flex; gap: 12px; overflow-x: auto; padding: 8px 0;">
                        ${Object.values(this.selectedComponents).map(product => `
                            <div class="product-card-build" style="cursor: default; flex: 0 0 160px; background: white; border-radius: 6px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                <div class="product-image" style="width: 100%; height: 120px; background: #f0f0f0; overflow: hidden;">
                                    <img src="${product.image_url || '/static/images/placeholder.png'}" alt="${product.name}" style="width: 100%; height: 100%; object-fit: cover;">
                                </div>
                                <div class="product-info" style="padding: 8px;">
                                    <h4 class="product-name" style="margin: 0 0 2px 0; font-size: 12px; font-weight: 600; color: #333; line-height: 1.2;">${product.name.substring(0, 35)}</h4>
                                    <p class="product-price" style="margin: 0; font-size: 13px; font-weight: 700; color: #667eea;">‚Ç±${parseFloat(product.price).toLocaleString('en-PH')}</p>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            container.appendChild(summaryDiv);
            container.scrollTop = container.scrollHeight;

            // Calculate total price
            const totalPrice = Object.values(this.selectedComponents).reduce((sum, p) => sum + parseFloat(p.price), 0);
            this.addMessage(`üìä **Build Total:** ‚Ç±${totalPrice.toLocaleString('en-PH')}`, 'bot');

            // Check for 3D models
            const has3DModels = Object.values(this.selectedComponents).some(p => p.model_3d);
            
            if (has3DModels) {
                setTimeout(() => {
                    this.showMultiModel3DOption();
                }, 800);
            } else {
                setTimeout(() => {
                    this.showBuildFinishOptions();
                }, 800);
            }
        }

        showMultiModel3DOption() {
            /**
             * Ask if user wants to view all 3D models together
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const optionDiv = document.createElement('div');
            optionDiv.className = 'custom-chat-message bot-message';
            optionDiv.innerHTML = `
                <div class="custom-chat-bubble" style="max-width: 100%; padding: 12px;">
                    <p style="margin: 0 0 12px 0; font-size: 13px; color: #333;">üí° Would you like to view all your selected components in one 3D canvas?</p>
                    <div style="display: flex; gap: 8px;">
                        <button class="view-multi-3d-btn" style="flex: 1; padding: 8px 12px; background: #764ba2; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">View 3D Canvas</button>
                        <button class="skip-multi-3d-btn" style="flex: 1; padding: 8px 12px; background: #999; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">No, Continue</button>
                    </div>
                </div>
            `;

            container.appendChild(optionDiv);
            container.scrollTop = container.scrollHeight;

            // View 3D Canvas
            optionDiv.querySelector('.view-multi-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                optionDiv.remove();
                this.show3DMultiModelCanvas();
            });

            // Skip
            optionDiv.querySelector('.skip-multi-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                optionDiv.remove();
                this.showBuildFinishOptions();
            });
        }

        show3DMultiModelCanvas() {
            /**
             * Display all selected 3D models in a single canvas
             * Models are positioned and spaced to avoid overlap
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const modelDiv = document.createElement('div');
            modelDiv.className = 'custom-chat-message bot-message';
            // Use unique ID with random suffix to ensure no collisions
            const viewerId = `multi-3d-viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const multiModelHtml = `
                <div class="custom-chat-bubble product-carousel-bubble" style="max-width: 100%; padding: 12px;">
                    <p style="margin: 0 0 10px 0; font-weight: 600; font-size: 13px; color: #333;">Your Build - 3D View</p>
                    <div id="${viewerId}" style="width: 100%; height: 350px; background: #d3d3d3; border-radius: 6px; position: relative; margin-bottom: 8px; pointer-events: auto; touch-action: none;"></div>
                    <p style="margin: 0 0 8px 0; font-size: 11px; color: #666; background: #f0f4ff; padding: 6px 8px; border-radius: 4px;">
                        üñ±Ô∏è Click & drag to move | Shift + drag to rotate | Scroll to zoom | Right-click & drag to pan
                    </p>

                    <div style="display: flex; gap: 8px;">
                        <button class="fullscreen-multi-3d-btn" style="flex: 1; padding: 8px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">‚õ∂ Full Screen</button>
                        <button class="continue-after-3d-btn" style="flex: 1; padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">Continue with Build</button>
                    </div>
                </div>
            `;
            modelDiv.innerHTML = multiModelHtml;

            container.appendChild(modelDiv);
            container.scrollTop = container.scrollHeight;

            // Save multi-model viewer to localStorage
            this.saveChatMessage(
                `Your Build - Multi 3D View`,
                'bot',
                false,
                {
                    type: 'multi-3d-model',
                    selectedComponents: JSON.stringify(this.selectedComponents)
                }
            );

            // Load multi-model viewer after ensuring THREE extensions are available
            this.waitForThreeExtensions().then(() => {
                this.loadMultiModel3DViewer(viewerId);
            });

            // Add fullscreen button listener
            modelDiv.querySelector('.fullscreen-multi-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.openFullscreenMultiModel3D();
            });

            // Add continue button listener
            modelDiv.querySelector('.continue-after-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.addMessage('Ready to finalize your build?', 'user');
                setTimeout(() => {
                    this.showBuildFinishOptions();
                }, 500);
            });

        }

        loadMultiModel3DViewer(viewerId) {
            /**
             * Load and display all selected 3D models in one canvas
             * PER-MODEL INTERACTION: Each model rotates individually when dragged
             * Uses raycasting to detect which model is being interacted with
             */
            
            // Prevent multiple 3D viewers from loading simultaneously
            const container = document.getElementById(viewerId);
            if (!container || container.dataset.viewerLoading === 'true') {
                console.log('3D viewer already loading or container not found');
                return;
            }
            
            // Mark this viewer as loading
            container.dataset.viewerLoading = 'true';

            // Get products with 3D models
            const modelsToLoad = Object.entries(this.selectedComponents)
                .filter(([_, product]) => product.model_3d)
                .map(([category, product]) => ({ 
                    category, 
                    ...product,
                    model_3d: product.model_3d.startsWith('http') ? product.model_3d : window.location.origin + product.model_3d
                }));

            if (modelsToLoad.length === 0) {
                container.innerHTML = '<p style="color: #999; padding: 20px; text-align: center; font-size: 12px;">No 3D models available</p>';
                return;
            }

            if (typeof THREE === 'undefined' || typeof THREE.GLTFLoader === 'undefined') {
                container.innerHTML = '<p style="color: red; padding: 20px; text-align: center; font-size: 12px;">3D viewer not available</p>';
                return;
            }

            try {
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                
                // Check if this is fullscreen mode
                const isFullscreen = container.id.includes('fullscreen');
                
                // Dynamic sizing based on device
                let canvas_width, canvas_height;
                const isMobile = window.innerWidth < 768;
                
                if (isFullscreen) {
                    // Full screen mode - use window dimensions with mobile adjustments
                    if (isMobile) {
                        canvas_width = window.innerWidth;
                        canvas_height = window.innerHeight - 120; // Account for header/footer on mobile
                    } else {
                        canvas_width = window.innerWidth;
                        canvas_height = window.innerHeight - 80; // Desktop header space
                    }
                } else {
                    // Chat view - responsive sizing
                    if (isMobile) {
                        // Mobile: use 100% width with height adjustment
                        canvas_width = container.clientWidth;
                        canvas_height = Math.min(container.clientHeight, window.innerHeight * 0.6);
                    } else {
                        // Desktop: cap at 1280x720
                        const maxWidth = 1280;
                        const maxHeight = 720;
                        canvas_width = Math.min(container.clientWidth, maxWidth);
                        canvas_height = Math.min(container.clientHeight, maxHeight);
                    }
                }
                
                canvas.width = canvas_width;
                canvas.height = canvas_height;
                canvas.style.pointerEvents = 'auto';
                canvas.style.touchAction = 'none';
                canvas.style.display = 'block';
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                container.style.touchAction = 'none';
                container.style.pointerEvents = 'auto';
                container.appendChild(canvas);

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xeeeeee);

                const camera = new THREE.PerspectiveCamera(
                    65, 
                    canvas.width / canvas.height, 
                    0.1, 
                    1000
                );
                
                // Adjust camera position based on screen size and model count
                const isMobileView = isMobile;
                camera.position.set(0, 0, isMobileView ? 12 : 15);

                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true, 
                    alpha: false,
                    powerPreference: 'high-performance',
                    preserveDrawingBuffer: true
                });
                renderer.setSize(canvas.width, canvas.height);
                renderer.setClearColor(0xeeeeee, 1);
                renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                const loader = new THREE.GLTFLoader();
                const models = [];
                const modelRotations = []; // Track rotation for each model
                let modelIndex = 0;
                let animationFrameId = null;
                let isAnimating = false;
                
                // Per-model interaction state
                let selectedModel = null;
                let isDragging = false;
                let isRotating = false;
                let isPanning = false;
                let previousMousePosition = { x: 0, y: 0 };
                let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                let dragPoint = new THREE.Vector3();
                let initialDragPoint = new THREE.Vector3();
                let initialModelPosition = new THREE.Vector3();
                let panOffset = new THREE.Vector3(0, 0, 0);
                
                // Raycaster for detecting which model is clicked
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                // Performance optimization: throttle mousemove
                let lastMouseMoveTime = 0;
                const mouseMoveThrottle = 16; // ~60fps

                // Animation loop
                const animate = () => {
                    // Check if container still exists
                    if (!document.contains(container)) {
                        isAnimating = false;
                        renderer.dispose();
                        if (container._cleanup) container._cleanup();
                        return;
                    }
                    
                    animationFrameId = requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                };
                
                // Start animation only once
                if (!isAnimating) {
                    isAnimating = true;
                    animate();
                }

                // Mouse down - detect which model is clicked
                const onMouseDown = (event) => {
                    event.stopPropagation();
                    event.preventDefault();
                    
                    // Calculate mouse position in normalized device coordinates
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                    
                    // Left-click (button 0) = rotate model
                    if (event.button === 0) {
                        // Update raycaster
                        raycaster.setFromCamera(mouse, camera);
                        
                        // Check which models are intersected
                        const intersects = raycaster.intersectObjects(models, true);
                        
                        if (intersects.length > 0) {
                            // Find which model was hit
                            for (let model of models) {
                                const isIntersected = intersects.some(intersection => {
                                    let obj = intersection.object;
                                    while (obj) {
                                        if (obj === model) return true;
                                        obj = obj.parent;
                                    }
                                    return false;
                                });
                                
                                if (isIntersected) {
                                    selectedModel = model;
                                    isRotating = true;
                                    isDragging = false;
                                    break;
                                }
                            }
                        }
                        return;
                    }
                    
                    // Right-click (button 2) = drag individual model
                    if (event.button === 2) {
                        // Update raycaster
                        raycaster.setFromCamera(mouse, camera);
                        
                        // Check which models are intersected
                        const intersects = raycaster.intersectObjects(models, true);
                        
                        if (intersects.length > 0) {
                            // Find which model was hit
                            for (let model of models) {
                                const isIntersected = intersects.some(intersection => {
                                    let obj = intersection.object;
                                    while (obj) {
                                        if (obj === model) return true;
                                        obj = obj.parent;
                                    }
                                    return false;
                                });
                                
                                if (isIntersected) {
                                    selectedModel = model;
                                    isDragging = true;
                                    isRotating = false;
                                    
                                    // Set up drag plane perpendicular to camera view at model's depth
                                    // Use Z-axis as normal so movement is on XY plane
                                    dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -model.position.z);
                                    
                                    // Get initial drag point on the plane
                                    raycaster.setFromCamera(mouse, camera);
                                    initialDragPoint = new THREE.Vector3();
                                    raycaster.ray.intersectPlane(dragPlane, initialDragPoint);
                                    initialModelPosition = model.position.clone();
                                    break;
                                }
                            }
                        }
                        return;
                    }
                };

                // Mouse move - handle dragging (pan or model manipulation)
                const onMouseMove = (event) => {
                    // Throttle mousemove for performance
                    const now = Date.now();
                    if (now - lastMouseMoveTime < mouseMoveThrottle) {
                        previousMousePosition = { x: event.clientX, y: event.clientY };
                        return;
                    }
                    lastMouseMoveTime = now;
                    
                    event.stopPropagation();
                    event.preventDefault();
                    
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;
                    
                    // Handle model rotation (left-click drag)
                    if (isRotating && selectedModel) {
                        selectedModel.rotation.y += deltaX * 0.01;
                        selectedModel.rotation.x += deltaY * 0.01;
                    }
                    // Handle model dragging (right-click drag)
                    else if (isDragging && selectedModel && dragPlane && initialDragPoint) {
                        // Calculate mouse position in normalized device coordinates
                        const rect = canvas.getBoundingClientRect();
                        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                        
                        // Raycast to drag plane to get world position
                        raycaster.setFromCamera(mouse, camera);
                        const currentDragPoint = new THREE.Vector3();
                        
                        // Raycast to get world position on the drag plane
                        const result = raycaster.ray.intersectPlane(dragPlane, currentDragPoint);
                        
                        if (result) {
                            // Calculate delta from initial drag point
                            const delta = result.clone().sub(initialDragPoint);
                            selectedModel.position.copy(initialModelPosition).add(delta);
                        }
                    }
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                };

                // Mouse up - stop dragging
                const onMouseUp = (event) => {
                    event.stopPropagation();
                    isDragging = false;
                    isRotating = false;
                    selectedModel = null;
                    dragPlane = null;
                    dragPoint = null;
                    initialDragPoint = null;
                    initialModelPosition = null;
                };

                // Wheel - zoom selected model or all if none selected
                const onWheel = (event) => {
                    event.stopPropagation();
                    event.preventDefault();
                    
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(models, true);
                    
                    const zoomAmount = event.deltaY > 0 ? 0.95 : 1.05;
                    
                    if (intersects.length > 0) {
                        // Find which model was hit - optimized search
                        const hitObject = intersects[0].object;
                        for (let model of models) {
                            // Check if hitObject is part of this model
                            if (model.uuid === hitObject.uuid || model.children.includes(hitObject) || hitObject.parent === model) {
                                model.scale.multiplyScalar(zoomAmount);
                                break;
                            }
                        }
                    }
                };

                // Attach event listeners
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
                canvas.addEventListener('wheel', onWheel, { passive: false });

                // Touch controls for mobile
                let touchStartDistance = 0;
                let lastTouchTime = 0;
                const touchThrottle = 16; // ~60fps
                let touchedModels = []; // Track which models are under touch points

                const onTouchStart = (event) => {
                    // Always prevent default to stop page scrolling
                    if (event.target === canvas || canvas.contains(event.target)) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    lastTouchTime = Date.now();
                    touchedModels = []; // Reset touched models
                    
                    if (event.touches.length === 1) {
                        // Single finger - treat as left-click (rotate)
                        const touch = event.touches[0];
                        const rect = canvas.getBoundingClientRect();
                        
                        // Calculate mouse position in normalized device coordinates
                        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                        
                        previousMousePosition = { x: touch.clientX, y: touch.clientY };
                        
                        // Update raycaster
                        raycaster.setFromCamera(mouse, camera);
                        
                        // Check which models are intersected
                        const intersects = raycaster.intersectObjects(models, true);
                        
                        if (intersects.length > 0) {
                            // Find which model was hit
                            for (let model of models) {
                                const isIntersected = intersects.some(intersection => {
                                    let obj = intersection.object;
                                    while (obj) {
                                        if (obj === model) return true;
                                        obj = obj.parent;
                                    }
                                    return false;
                                });
                                
                                if (isIntersected) {
                                    selectedModel = model;
                                    touchedModels = [model]; // Track this touched model
                                    isRotating = true;
                                    isDragging = false;
                                    break;
                                }
                            }
                        }
                    } else if (event.touches.length === 2) {
                        // Two fingers - detect which models are under each touch
                        const touch1 = event.touches[0];
                        const touch2 = event.touches[1];
                        const rect = canvas.getBoundingClientRect();
                        
                        // Raycast first touch
                        mouse.x = ((touch1.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((touch1.clientY - rect.top) / rect.height) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const intersects1 = raycaster.intersectObjects(models, true);
                        
                        // Raycast second touch
                        mouse.x = ((touch2.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((touch2.clientY - rect.top) / rect.height) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const intersects2 = raycaster.intersectObjects(models, true);
                        
                        // Collect which models are under the touch points
                        for (let model of models) {
                            const onTouch1 = intersects1.some(intersection => {
                                let obj = intersection.object;
                                while (obj) {
                                    if (obj === model) return true;
                                    obj = obj.parent;
                                }
                                return false;
                            });
                            
                            const onTouch2 = intersects2.some(intersection => {
                                let obj = intersection.object;
                                while (obj) {
                                    if (obj === model) return true;
                                    obj = obj.parent;
                                }
                                return false;
                            });
                            
                            if (onTouch1 || onTouch2) {
                                touchedModels.push(model);
                            }
                        }
                        
                        // For two-finger interaction on models
                        selectedModel = touchedModels.length > 0 ? touchedModels[0] : null;
                        
                        // Two fingers can pinch zoom or rotate
                        const dx = touch1.clientX - touch2.clientX;
                        const dy = touch1.clientY - touch2.clientY;
                        touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                        previousMousePosition = { x: (touch1.clientX + touch2.clientX) / 2, y: (touch1.clientY + touch2.clientY) / 2 };
                        isRotating = true;
                    }
                };

                const onTouchMove = (event) => {
                    // Always prevent default on the canvas to stop page scrolling
                    if (event.target === canvas || canvas.contains(event.target)) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    
                    const now = Date.now();
                    if (now - lastTouchTime < touchThrottle) return;
                    lastTouchTime = now;
                    
                    if (event.touches.length === 1) {
                        // Single finger - rotate only the touched model
                        const touch = event.touches[0];
                        const deltaX = touch.clientX - previousMousePosition.x;
                        const deltaY = touch.clientY - previousMousePosition.y;
                        
                        // Handle model rotation - only if it's a touched model
                        if (isRotating && selectedModel && touchedModels.includes(selectedModel)) {
                            selectedModel.rotation.y += deltaX * 0.01;
                            selectedModel.rotation.x += deltaY * 0.01;
                        }
                        
                        previousMousePosition = { x: touch.clientX, y: touch.clientY };
                    } else if (event.touches.length === 2) {
                        // Two fingers - pinch zoom on touched models only
                        const touch1 = event.touches[0];
                        const touch2 = event.touches[1];
                        const dx = touch1.clientX - touch2.clientX;
                        const dy = touch1.clientY - touch2.clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const centerX = (touch1.clientX + touch2.clientX) / 2;
                        const centerY = (touch1.clientY + touch2.clientY) / 2;
                        
                        if (touchStartDistance > 0 && touchedModels.length > 0) {
                            // Pinch gesture - zoom only touched models
                            const zoomAmount = distance > touchStartDistance ? 1.05 : 0.95;
                            
                            // Zoom only the touched models
                            touchedModels.forEach(model => {
                                model.scale.multiplyScalar(zoomAmount);
                            });
                            
                            // Also rotate touched models based on finger movement
                            const deltaX = centerX - previousMousePosition.x;
                            const deltaY = centerY - previousMousePosition.y;
                            
                            if (isRotating && selectedModel && touchedModels.includes(selectedModel)) {
                                selectedModel.rotation.y += deltaX * 0.005;
                                selectedModel.rotation.x += deltaY * 0.005;
                            }
                            
                            touchStartDistance = distance;
                        }
                        
                        previousMousePosition = { x: centerX, y: centerY };
                    }
                };

                const onTouchEnd = (event) => {
                    if (event.target === canvas || canvas.contains(event.target)) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    
                    isDragging = false;
                    isRotating = false;
                    selectedModel = null;
                    touchedModels = [];  // Clear the touched models array
                    touchStartDistance = 0;
                };

                canvas.addEventListener('touchstart', onTouchStart, { passive: false });
                canvas.addEventListener('touchmove', onTouchMove, { passive: false });
                canvas.addEventListener('touchend', onTouchEnd, { passive: false });

                // Load models sequentially
                const loadNextModel = () => {
                    if (modelIndex >= modelsToLoad.length) {
                        if (models.length === 0) {
                            container.innerHTML = '<p style="color: red; padding: 20px; text-align: center; font-size: 12px;">Unable to load models</p>';
                        }
                        return;
                    }

                    const item = modelsToLoad[modelIndex];
                    const index = modelIndex;
                    modelIndex++;

                    loader.load(item.model_3d, (gltf) => {
                        let model = gltf.scene;
                        
                        // Responsive positioning based on screen size and model count
                        const isMobileLayout = window.innerWidth < 768;
                        const modelCount = modelsToLoad.length;
                        
                        let xPos, yPos;
                        
                        if (isMobileLayout) {
                            // Mobile: stack vertically or in grid
                            if (modelCount <= 2) {
                                // Single or dual: vertical stack
                                yPos = (index - modelCount / 2 + 0.5) * 5;
                                xPos = 0;
                            } else if (modelCount <= 4) {
                                // 3-4 models: 2x2 grid
                                const row = Math.floor(index / 2);
                                const col = index % 2;
                                xPos = (col - 0.5) * 4;
                                yPos = (row - 0.5) * 4;
                            } else {
                                // 5+ models: 3x3 grid
                                const row = Math.floor(index / 3);
                                const col = index % 3;
                                xPos = (col - 1) * 3.5;
                                yPos = (row - 1) * 3.5;
                            }
                        } else {
                            // Desktop: horizontal spacing
                            if (modelCount <= 3) {
                                const spacing = 6;
                                xPos = (index - modelCount / 2 + 0.5) * spacing;
                                yPos = 0;
                            } else {
                                // Multiple rows for many models
                                const cols = Math.ceil(modelCount / 2);
                                const row = Math.floor(index / cols);
                                const col = index % cols;
                                xPos = (col - cols / 2 + 0.5) * 5;
                                yPos = (row - 0.5) * 4;
                            }
                        }
                        
                        model.position.set(xPos, yPos, 0);
                        
                        // Scale model
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = isMobileLayout ? 2.5 / maxDim : 3.5 / maxDim;
                        
                        const center = box.getCenter(new THREE.Vector3());
                        model.position.sub(center);
                        model.position.set(xPos, yPos, 0);
                        model.scale.multiplyScalar(scale);
                        
                        scene.add(model);
                        models.push(model);
                        modelRotations.push({ x: 0, y: 0 });
                        
                        setTimeout(loadNextModel, 50);
                    }, undefined, () => {
                        setTimeout(loadNextModel, 50);
                    });
                };

                loadNextModel();

                // Handle resize
                const handleResize = () => {
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                };
                window.addEventListener('resize', handleResize);
                
                // Store cleanup function
                container._cleanup = () => {
                    window.removeEventListener('resize', handleResize);
                    canvas.removeEventListener('mousedown', onMouseDown);
                    canvas.removeEventListener('mousemove', onMouseMove);
                    canvas.removeEventListener('mouseup', onMouseUp);
                    canvas.removeEventListener('wheel', onWheel);
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    renderer.dispose();
                };
                
            } catch (error) {
                console.error('Error in multi-model viewer:', error);
                container.innerHTML = '<p style="color: red; padding: 20px; text-align: center; font-size: 12px;">Error loading viewer</p>';
            }
        }

        showBuildFinishOptions() {
            /**
             * Show options to finish building (add to cart, modify, continue chat)
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const optionDiv = document.createElement('div');
            optionDiv.className = 'custom-chat-message bot-message';
            
            // Different buttons based on login status
            const cartButtonHTML = this.isLoggedIn ? 
                `<button class="add-to-cart-btn" style="flex: 1; min-width: 100px; padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">‚ûï Add All to Cart</button>` :
                `<button class="login-to-cart-btn" style="flex: 1; min-width: 100px; padding: 8px 12px; background: #FF6B35; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">üîê Login to Add to Cart</button>`;
            
            optionDiv.innerHTML = `
                <div class="custom-chat-bubble" style="max-width: 100%; padding: 12px;">
                    <p style="margin: 0 0 12px 0; font-size: 13px; color: #333;">What would you like to do next?</p>
                    <div class="build-finish-buttons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        ${cartButtonHTML}
                        <button class="modify-build-btn" style="flex: 1; padding: 8px 12px; background: #ff9800; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">‚úèÔ∏è Modify Build</button>
                        <button class="start-over-btn" style="flex: 1; padding: 8px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">üîÑ Start Over</button>
                        <button class="continue-chat-btn" style="flex: 1; padding: 8px 12px; background: #033F63; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">üí¨ Continue Chat</button>
                    </div>
                </div>
            `;

            container.appendChild(optionDiv);
            container.scrollTop = container.scrollHeight;

            // Add to Cart - add all selected components (logged-in users only)
            if (this.isLoggedIn) {
                optionDiv.querySelector('.add-to-cart-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    optionDiv.remove();
                    this.addAllBuildItemsToCart();
                });
            } else {
                // Login to Add to Cart button
                optionDiv.querySelector('.login-to-cart-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    optionDiv.remove();
                    this.showLoginPrompt();
                });
            }

            // Modify Build - go back to component selection
            optionDiv.querySelector('.modify-build-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                optionDiv.remove();
                this.addMessage('Which component would you like to modify or add?', 'bot');
                this.currentComponentIndex = 0;
                this.buildInProgress = true;
                this.saveBuildState();
                setTimeout(() => {
                    this.displayComponentCategories();
                }, 500);
            });

            // Start Over - begin a completely new build
            optionDiv.querySelector('.start-over-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                optionDiv.remove();
                // Clear build state completely
                this.selectedComponents = {};
                this.currentComponentIndex = 0;
                this.buildInProgress = true;
                sessionStorage.removeItem('currentBuildState');
                this.addMessage('üîÑ Starting a fresh build! Let\'s build a new computer from scratch.', 'bot');
                setTimeout(() => {
                    this.addMessage('üëã Hi! I\'m Koyanardz Assistant. I\'d love to help you build a computer! To give you the best recommendations, could you tell me a bit more about what you\'re looking for?\n\n‚Ä¢ **What will be the primary use for your computer** (e.g., gaming, work, video editing, general use)?\n‚Ä¢ **Do you have an approximate budget in mind?**\n‚Ä¢ **Are you interested in new or secondhand parts**, or a mix of both?\n‚Ä¢ **Do you need help with just the core computer components**, or a full setup including a monitor and peripherals?\n\nWe also offer custom PC builds and can help you inspect components before purchase. Let me know your preferences, and we can start looking at the right parts for you!', 'bot');
                    
                    // After intro, add the component categories
                    setTimeout(() => {
                        this.displayComponentCategories();
                    }, 800);
                }, 500);
            });

            // Continue chat - keep build state saved for future reference
            optionDiv.querySelector('.continue-chat-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                optionDiv.remove();
                this.addMessage('Great! How else can I help you today? (Your build has been saved - just say "show me my build" or "modify my build" anytime!)', 'bot');
                this.saveBuildState();
                this.saveChatConversation();
                this.showQuickActions();
            });
        }

        showLoginPrompt() {
            /**
             * Show login prompt for users who want to add to cart
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const loginDiv = document.createElement('div');
            loginDiv.className = 'custom-chat-message bot-message';
            loginDiv.innerHTML = `
                <div class="custom-chat-bubble" style="max-width: 100%; padding: 12px; background: #FFF3CD; border: 1px solid #FFE69C;">
                    <p style="margin: 0 0 12px 0; font-size: 13px; color: #333; font-weight: 600;">üîê Login Required</p>
                    <p style="margin: 0 0 12px 0; font-size: 12px; color: #555;">To add items to your cart and complete your purchase, please log in or create an account.</p>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="goto-login-btn" style="flex: 1; padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">‚úÖ Go to Login</button>
                        <button class="save-build-btn" style="flex: 1; padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">üíæ Save Build</button>
                        <button class="continue-shopping-btn" style="flex: 1; padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">üõçÔ∏è Keep Shopping</button>
                    </div>
                </div>
            `;

            container.appendChild(loginDiv);
            container.scrollTop = container.scrollHeight;

            // Go to Login button
            loginDiv.querySelector('.goto-login-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                // Save build and conversation before redirecting
                this.saveBuildState();
                this.saveChatConversation();
                window.location.href = '/login/?next=' + encodeURIComponent(window.location.pathname);
            });

            // Save Build button
            loginDiv.querySelector('.save-build-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                loginDiv.remove();
                this.saveBuildState();
                this.saveChatConversation();
                this.addMessage('‚úÖ Your build and chat have been saved! You can continue when you log in.', 'bot');
                setTimeout(() => {
                    this.showBuildFinishOptions();
                }, 800);
            });

            // Continue Shopping button
            loginDiv.querySelector('.continue-shopping-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                loginDiv.remove();
                this.saveBuildState();
                this.addMessage('Got it! Feel free to continue exploring and modifying your build. Log in anytime to add to cart!', 'bot');
                setTimeout(() => {
                    this.showQuickActions();
                }, 500);
            });
        }

        addAllBuildItemsToCart() {
            /**
             * Add all selected components to cart via CSRF protected endpoint
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const items = Object.entries(this.selectedComponents).map(([category, product]) => ({
                product_id: product.id,
                quantity: 1
            }));

            if (items.length === 0) {
                this.addMessage('No items to add to cart.', 'bot');
                return;
            }

            // Show loading message
            this.showTypingIndicator();

            // Add items one by one to cart
            let addedCount = 0;
            let failedCount = 0;

            const addItemToCart = (index) => {
                if (index >= items.length) {
                    this.hideTypingIndicator();
                    
                    if (failedCount === 0) {
                        this.addMessage(`‚úÖ **Success!** Added ${addedCount} item${addedCount !== 1 ? 's' : ''} to your cart!\n\nüõí You can review your cart and proceed to checkout.`, 'bot');
                        // Save conversation after successful cart addition
                        this.saveChatConversation();
                        // Trigger cart update event if listeners exist
                        window.dispatchEvent(new CustomEvent('cartUpdated', { detail: { itemsAdded: addedCount } }));
                    } else {
                        this.addMessage(`‚ö†Ô∏è Added ${addedCount} item${addedCount !== 1 ? 's' : ''} but ${failedCount} failed to add. Please try again.`, 'bot');
                    }
                    
                    setTimeout(() => {
                        this.showBuildFinishOptions();
                    }, 500);
                    return;
                }

                const item = items[index];
                
                // Get CSRF token
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || document.querySelector('input[name="csrfmiddlewaretoken"]')?.value;

                fetch(`/add-to-cart/${item.product_id}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken || ''
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        quantity: item.quantity
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.message || data.cart_count) {
                        addedCount++;
                    } else if (data.error) {
                        failedCount++;
                    } else {
                        addedCount++;
                    }
                    addItemToCart(index + 1);
                })
                .catch(error => {
                    console.error('Error adding to cart:', error);
                    failedCount++;
                    addItemToCart(index + 1);
                });
            };

            addItemToCart(0);
        }

        resetBuild() {
            /**
             * Reset build state
             */
            this.selectedComponents = {};
            this.currentComponentIndex = 0;
            this.buildInProgress = false;
            // Clear build state from localStorage
            localStorage.removeItem('currentBuildState');
        }

        saveBuildState() {
            /**
             * Save current build state to localStorage for persistence across page refreshes
             * Validates all data before saving
             */
            try {
                // Validate selectedComponents is an object
                const selectedComponents = this.selectedComponents || {};
                if (typeof selectedComponents !== 'object' || Array.isArray(selectedComponents)) {
                    console.error('‚ùå selectedComponents is invalid:', typeof selectedComponents);
                    return;
                }

                // Validate currentComponentIndex is a number
                const currentComponentIndex = typeof this.currentComponentIndex === 'number' 
                    ? this.currentComponentIndex 
                    : 0;

                // Validate buildInProgress is a boolean
                const buildInProgress = Boolean(this.buildInProgress);

                // Create build state object
                const buildState = {
                    selectedComponents: selectedComponents,
                    currentComponentIndex: currentComponentIndex,
                    buildInProgress: buildInProgress,
                    currentBuildCategory: String(this.currentBuildCategory || 'PC'),
                    timestamp: Date.now ? new Date().getTime() : Math.floor(Date.now()),
                    version: 1 // For future compatibility
                };

                // Validate the entire state before saving
                const stateJson = JSON.stringify(buildState);
                if (!stateJson || stateJson.length === 0) {
                    console.error('‚ùå Failed to serialize build state');
                    return;
                }

                // Save to localStorage with quota handling
                localStorage.setItem('currentBuildState', stateJson);
                console.log('‚úÖ Build state saved');

            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.error('‚ùå localStorage quota exceeded for build state');
                    try {
                        localStorage.removeItem('currentBuildState');
                    } catch (clearError) {
                        console.error('‚ùå Failed to clear build state:', clearError);
                    }
                } else {
                    console.error('‚ùå Error saving build state:', e.message);
                }
            }
        }

        loadBuildState() {
            /**
             * Load build state from localStorage if available
             * Validates all data before using it
             */
            try {
                const savedState = localStorage.getItem('currentBuildState');
                
                if (!savedState || savedState.trim() === '') {
                    return false;
                }

                let buildState;
                try {
                    buildState = JSON.parse(savedState);
                } catch (parseError) {
                    console.error('‚ùå Failed to parse build state:', parseError);
                    localStorage.removeItem('currentBuildState');
                    return false;
                }

                // Validate buildState is an object
                if (!buildState || typeof buildState !== 'object') {
                    console.error('‚ùå Build state is not an object');
                    return false;
                }

                // Validate buildInProgress flag
                if (!buildState.buildInProgress || buildState.buildInProgress !== true) {
                    console.log('No build in progress to restore');
                    return false;
                }

                // Validate selectedComponents
                if (buildState.selectedComponents && typeof buildState.selectedComponents === 'object') {
                    this.selectedComponents = buildState.selectedComponents;
                } else {
                    this.selectedComponents = {};
                }

                // Validate currentComponentIndex
                if (typeof buildState.currentComponentIndex === 'number' && buildState.currentComponentIndex >= 0) {
                    this.currentComponentIndex = buildState.currentComponentIndex;
                } else {
                    this.currentComponentIndex = 0;
                }

                // Restore build state
                this.buildInProgress = true;
                this.currentBuildCategory = buildState.currentBuildCategory || 'PC';
                
                console.log('‚úÖ Build state restored');
                return true;

            } catch (error) {
                console.error('‚ùå Error loading build state:', error.message);
                return false;
            }
        }

        saveChatConversation() {
            /**
             * Save current chat conversation to backend
             */
            if (!this.conversationHistory || this.conversationHistory.length === 0) {
                return;
            }

            const payload = {
                session_id: this.sessionId,
                messages: this.conversationHistory,
                build_state: {
                    selectedComponents: this.selectedComponents,
                    currentComponentIndex: this.currentComponentIndex,
                    buildInProgress: this.buildInProgress
                }
            };

            // Get CSRF token
            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
            
            const headers = {
                'Content-Type': 'application/json'
            };

            if (csrfToken) {
                headers['X-CSRFToken'] = csrfToken;
            }

            fetch('/api/chat/save/', {
                method: 'POST',
                headers: headers,
                credentials: 'same-origin',
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Chat conversation saved successfully');
                }
            })
            .catch(error => {
                console.error('Error saving chat conversation:', error);
            });
        }

        show3DModelInChat(modelUrl, productName) {
            /**
             * Display 3D model in a chat-embedded viewer with full-screen option
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const modelDiv = document.createElement('div');
            modelDiv.className = 'custom-chat-message bot-message';
            // Use unique ID with Math.random() to ensure no collisions
            const viewerId = `chat-3d-viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            modelDiv.innerHTML = `
                <div class="custom-chat-bubble product-carousel-bubble" style="max-width: 100%; padding: 12px;">
                    <p style="margin: 0 0 10px 0; font-weight: 600; font-size: 13px; color: #333;">${productName} - 3D Model</p>
                    <div id="${viewerId}" style="width: 100%; height: 280px; background: #d3d3d3; border-radius: 6px; position: relative; margin-bottom: 8px; cursor: pointer; pointer-events: auto; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;" class="fullscreen-3d-trigger"></div>
                    <div style="display: flex; gap: 8px;">
                        <p style="flex: 1; margin: 0; font-size: 11px; color: #666; background: #f0f4ff; padding: 6px 8px; border-radius: 4px;">
                            üñ±Ô∏è Left-click + drag to rotate | Scroll to zoom
                        </p>
                        <button class="fullscreen-3d-btn" style="padding: 6px 10px; background: #667eea; color: white; border: none; border-radius: 4px; font-size: 11px; cursor: pointer; font-weight: 600; white-space: nowrap;">‚õ∂ Full Screen</button>
                    </div>
                </div>
            `;

            container.appendChild(modelDiv);
            container.scrollTop = container.scrollHeight;

            // Save 3D model metadata to localStorage for persistence
            this.saveChatMessage(
                `3D Model: ${productName}`,
                'bot',
                false,
                {
                    type: '3d-model',
                    modelUrl: modelUrl,
                    productName: productName
                }
            );

            // Load 3D model after ensuring THREE extensions are available
            this.waitForThreeExtensions().then(() => {
                this.loadChatEmbedded3DModel(viewerId, modelUrl, productName);
                
                // Add full-screen button listener
                modelDiv.querySelector('.fullscreen-3d-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.openFullscreen3DViewer(modelUrl, productName);
                });
            });
        }

        openFullscreen3DViewer(modelUrl, productName) {
            /**
             * Open 3D model in a full-screen modal
             */
            const modal = document.createElement('div');
            modal.className = 'fullscreen-3d-modal';
            modal.innerHTML = `
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; background: #000;">
                    <div style="background: #667eea; color: white; padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; font-weight: 600;">
                        <span>üéÆ ${productName} - 3D Model Viewer</span>
                        <button class="close-fullscreen-btn" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">&times;</button>
                    </div>
                    <div id="fullscreen-3d-canvas-${Date.now()}" style="flex: 1; position: relative; background: #d3d3d3;"></div>
                    <div style="background: #333; color: #aaa; padding: 10px 16px; font-size: 12px; border-top: 1px solid #555;">
                        üñ±Ô∏è <strong>Controls:</strong> Left-click + drag to rotate | Scroll to zoom | Right-click + drag to pan
                    </div>
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                z-index: 2000;
                display: flex;
                flex-direction: column;
                will-change: transform;
            `;
            
            document.body.appendChild(modal);
            
            // Get canvas ID and load model
            const canvasId = modal.querySelector('[id^="fullscreen-3d-canvas-"]').id;
            
            // Close button
            modal.querySelector('.close-fullscreen-btn').addEventListener('click', () => {
                modal.remove();
            });
            
            // Load the 3D model in full screen
            setTimeout(() => {
                this.waitForThreeExtensions().then(() => {
                    this.loadChatEmbedded3DModel(canvasId, modelUrl, productName, true);
                });
            }, 100);
        }

        openFullscreenMultiModel3D() {
            /**
             * Open all selected 3D models in a full-screen modal
             */
            const modal = document.createElement('div');
            modal.className = 'fullscreen-multi-3d-modal';
            
            const isMobile = window.innerWidth < 768;
            const headerHeight = isMobile ? '70px' : '50px';
            const footerHeight = isMobile ? '70px' : '50px';
            
            modal.innerHTML = `
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; background: #000; margin: 0; padding: 0; overflow: hidden;">
                    <div style="background: #764ba2; color: white; padding: ${isMobile ? '10px 12px' : '12px 16px'}; display: flex; justify-content: space-between; align-items: center; font-weight: 600; flex-shrink: 0; font-size: ${isMobile ? '14px' : '16px'}; height: ${headerHeight}; box-sizing: border-box;">
                        <span>üéÆ Your Build - Multi-Model 3D Viewer</span>
                        <button class="close-fullscreen-multi-btn" style="background: none; border: none; color: white; font-size: ${isMobile ? '28px' : '24px'}; cursor: pointer; padding: 0; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">&times;</button>
                    </div>
                    <div id="fullscreen-multi-3d-canvas-${Date.now()}" style="flex: 1; position: relative; background: #d3d3d3; width: 100%; overflow: hidden;"></div>
                    <div style="background: #333; color: #aaa; padding: ${isMobile ? '8px 12px' : '10px 16px'}; font-size: ${isMobile ? '11px' : '12px'}; border-top: 1px solid #555; flex-shrink: 0; height: ${footerHeight}; box-sizing: border-box; overflow-y: auto;">
                        üñ±Ô∏è <strong>Controls:</strong> ${isMobile ? 'Drag to rotate | Pinch to zoom | Long-press & drag to move' : 'Left-click + drag to rotate | Scroll to zoom | Right-click & drag to pan'}
                    </div>
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                z-index: 2000;
                display: flex;
                flex-direction: column;
                will-change: transform;
                margin: 0;
                padding: 0;
                overflow: hidden;
            `;
            
            document.body.appendChild(modal);
            
            // Get canvas ID and load models
            const canvasId = modal.querySelector('[id^="fullscreen-multi-3d-canvas-"]').id;
            
            // Close button
            modal.querySelector('.close-fullscreen-multi-btn').addEventListener('click', () => {
                modal.remove();
            });
            
            // Load the 3D models in full screen
            setTimeout(() => {
                this.waitForThreeExtensions().then(() => {
                    this.loadMultiModel3DViewer(canvasId);
                });
            }, 100);
        }

        async waitForThreeExtensions() {
            /**
             * Wait for THREE.js, GLTFLoader, and OrbitControls to be available
             * They are loaded from local static files via navigation.html
             */
            return new Promise((resolve) => {
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max (100ms per attempt)
                
                const checkReady = () => {
                    attempts++;
                    
                    // Check for the ready flag first
                    if (typeof window.THREE_READY !== 'undefined' && window.THREE_READY === true) {
                        console.log('‚úì THREE.js ready flag detected');
                        resolve();
                        return;
                    }
                    
                    // Check if THREE exists with extensions attached
                    if (typeof THREE !== 'undefined') {
                        let hasGLTF = typeof THREE.GLTFLoader !== 'undefined';
                        let hasOrbit = typeof THREE.OrbitControls !== 'undefined';
                        
                        // If both extensions are ready, we're done
                        if (hasGLTF && hasOrbit) {
                            console.log('‚úì All THREE extensions ready');
                            window.THREE_READY = true;
                            resolve();
                            return;
                        }
                        
                        // If at least THREE is loaded, keep waiting
                        if (attempts >= maxAttempts) {
                            console.warn('‚ö†Ô∏è THREE.js loaded but waiting for extensions (may still work)');
                            console.warn(`  - GLTFLoader: ${hasGLTF ? '‚úì' : '‚úó'}`);
                            console.warn(`  - OrbitControls: ${hasOrbit ? '‚úì' : '‚úó'}`);
                            resolve(); // Continue anyway
                            return;
                        }
                    }
                    
                    // Timeout check
                    if (attempts >= maxAttempts) {
                        console.error('‚ùå THREE.js extensions failed to load');
                        resolve(); // Resolve anyway to prevent infinite loops
                        return;
                    }
                    
                    // Keep checking
                    setTimeout(checkReady, 100);
                };
                
                checkReady();
            });
        }

        loadChatEmbedded3DModel(viewerId, modelUrl, productName, isFullscreen = false) {
            /**
             * Load and display 3D model in chat or fullscreen
             * ISOLATED: Each viewer has its own scene, camera, renderer, and controls
             * WITH PROPER EVENT SCOPING
             */
            const container = document.getElementById(viewerId);
            if (!container) {
                console.error('Container not found:', viewerId);
                return;
            }

            // Ensure URL is absolute
            const absoluteUrl = modelUrl.startsWith('http') ? modelUrl : window.location.origin + modelUrl;

            // Check if THREE is available
            if (typeof THREE === 'undefined') {
                console.error('THREE.js not available');
                container.innerHTML = '<p style="color: red; padding: 20px; text-align: center; font-size: 12px;">3D viewer not available. Please refresh the page.</p>';
                return;
            }

            try {
                // First, clear container and create canvas element
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.display = 'block';
                canvas.style.pointerEvents = 'auto';
                canvas.style.touchAction = 'none';
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                container.appendChild(canvas);
                
                // Initialize Three.js scene - ISOLATED FOR THIS VIEWER ONLY
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xeeeeee);

                const width = container.clientWidth;
                const height = container.clientHeight;
                
                if (width <= 0 || height <= 0) {
                    console.error('Invalid container dimensions:', width, height);
                    container.innerHTML = '<p style="color: red; padding: 20px; text-align: center; font-size: 12px;">Invalid container size</p>';
                    return;
                }

                const camera = new THREE.PerspectiveCamera(65, width / height, 0.1, 1000);
                camera.position.set(0, 2, 4);

                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true, 
                    alpha: false,
                    powerPreference: 'high-performance',
                    preserveDrawingBuffer: true
                });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor(0xeeeeee, 1);
                renderer.outputEncoding = THREE.sRGBEncoding;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // Animation frame ID for this specific viewer - ISOLATED
                let animationFrameId = null;
                let isAnimating = false;
                const eventListeners = [];

                // Controls - Try to use OrbitControls, fallback if not available
                let controls = null;
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = false;
                    controls.autoRotate = false;
                    controls.autoRotateSpeed = 0;
                    
                    // Prevent event propagation from OrbitControls
                    const origMouseDown = controls.onMouseDown;
                    if (origMouseDown) {
                        controls.onMouseDown = (event) => {
                            event.stopPropagation();
                            origMouseDown.call(controls, event);
                        };
                    }
                } else {
                    console.warn('‚ö†Ô∏è OrbitControls not available - basic camera controls only');
                    // Add basic mouse control fallback - ISOLATED TO THIS CANVAS ONLY
                    let isDragging = false;
                    let previousMousePosition = { x: 0, y: 0 };
                    let previousTouchDistance = 0;
                    
                    const onMouseDown = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        isDragging = true;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    };
                    
                    const onMouseMove = (e) => {
                        if (isDragging) {
                            e.stopPropagation();
                            e.preventDefault();
                            const deltaX = e.clientX - previousMousePosition.x;
                            const deltaY = e.clientY - previousMousePosition.y;
                            
                            // Simple rotation fallback - ONLY affects THIS scene
                            if (scene.children.length > 2) { // Skip lights
                                const models = scene.children.filter(child => !(child instanceof THREE.Light || child instanceof THREE.Camera));
                                if (models.length > 0) {
                                    const model = models[0];
                                    model.rotation.y += deltaX * 0.005;
                                    model.rotation.x += deltaY * 0.005;
                                }
                            }
                            
                            previousMousePosition = { x: e.clientX, y: e.clientY };
                        }
                    };
                    
                    const onMouseUp = (e) => {
                        e.stopPropagation();
                        isDragging = false;
                    };
                    
                    const onWheel = (e) => {
                        if (isDragging) return;
                        e.stopPropagation();
                        e.preventDefault();
                        if (scene.children.length > 2) {
                            const models = scene.children.filter(child => !(child instanceof THREE.Light || child instanceof THREE.Camera));
                            if (models.length > 0) {
                                const model = models[0];
                                const zoomAmount = e.deltaY > 0 ? 1.1 : 0.9;
                                model.scale.multiplyScalar(zoomAmount);
                            }
                        }
                    };

                    // Touch controls for mobile devices
                    const onTouchStart = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        if (e.touches.length === 1) {
                            // Single finger - rotation
                            isDragging = true;
                            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        } else if (e.touches.length === 2) {
                            // Two fingers - zoom
                            const dx = e.touches[0].clientX - e.touches[1].clientX;
                            const dy = e.touches[0].clientY - e.touches[1].clientY;
                            previousTouchDistance = Math.sqrt(dx * dx + dy * dy);
                            isDragging = false;
                        }
                    };

                    const onTouchMove = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        
                        if (e.touches.length === 1 && isDragging) {
                            // Single finger drag - rotation
                            const deltaX = e.touches[0].clientX - previousMousePosition.x;
                            const deltaY = e.touches[0].clientY - previousMousePosition.y;
                            
                            // Find and rotate the model
                            const models = scene.children.filter(child => !(child instanceof THREE.Light || child instanceof THREE.Camera));
                            if (models.length > 0) {
                                const model = models[0];
                                model.rotation.y += deltaX * 0.005;
                                model.rotation.x += deltaY * 0.005;
                            }
                            
                            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        } else if (e.touches.length === 2) {
                            // Two finger pinch - zoom
                            const dx = e.touches[0].clientX - e.touches[1].clientX;
                            const dy = e.touches[0].clientY - e.touches[1].clientY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (previousTouchDistance > 0) {
                                // Find and zoom the model
                                const models = scene.children.filter(child => !(child instanceof THREE.Light || child instanceof THREE.Camera));
                                if (models.length > 0) {
                                    const model = models[0];
                                    // Pinch closer = zoom in (multiply by > 1), pinch further = zoom out (multiply by < 1)
                                    const zoomAmount = distance > previousTouchDistance ? 1.05 : 0.95;
                                    model.scale.multiplyScalar(zoomAmount);
                                }
                            }
                            
                            previousTouchDistance = distance;
                        }
                    };

                    const onTouchEnd = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        isDragging = false;
                        previousTouchDistance = 0;
                    };
                    
                    renderer.domElement.addEventListener('mousedown', onMouseDown);
                    renderer.domElement.addEventListener('mousemove', onMouseMove);
                    renderer.domElement.addEventListener('mouseup', onMouseUp);
                    renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
                    renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                    renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                    renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                    
                    eventListeners.push({ type: 'mousedown', handler: onMouseDown });
                    eventListeners.push({ type: 'mousemove', handler: onMouseMove });
                    eventListeners.push({ type: 'mouseup', handler: onMouseUp });
                    eventListeners.push({ type: 'wheel', handler: onWheel });
                    eventListeners.push({ type: 'touchstart', handler: onTouchStart });
                    eventListeners.push({ type: 'touchmove', handler: onTouchMove });
                    eventListeners.push({ type: 'touchend', handler: onTouchEnd });
                    
                    // Store cleanup function for when container is removed
                    container._cleanup = () => {
                        eventListeners.forEach(({ type, handler }) => {
                            renderer.domElement.removeEventListener(type, handler);
                        });
                    };
                }

                // Load model
                if (typeof THREE.GLTFLoader === 'undefined') {
                    console.error('GLTFLoader not available - cannot load model');
                    container.innerHTML = '<p style="color: #ff6b6b; padding: 20px; text-align: center; font-size: 12px;">‚ö†Ô∏è 3D loader not available. <br/>Please refresh the page to reload libraries.</p>';
                    return;
                }

                const loader = new THREE.GLTFLoader();
                console.log('Loading 3D model:', absoluteUrl);

                loader.load(
                    absoluteUrl,
                    (gltf) => {
                        console.log('‚úì Model loaded successfully');
                        const model = gltf.scene;
                        scene.add(model);

                        // Auto-center and scale
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 4 / maxDim;

                        model.position.sub(center);
                        model.scale.multiplyScalar(scale);

                        // Animation loop - ISOLATED TO THIS VIEWER ONLY
                        // Only start animation if not already animating
                        if (!isAnimating) {
                            isAnimating = true;
                            
                            function animate() {
                                // Only continue if container is still in DOM
                                if (!document.contains(container)) {
                                    isAnimating = false;
                                    renderer.dispose();
                                    if (container._cleanup) container._cleanup();
                                    return;
                                }
                                
                                animationFrameId = requestAnimationFrame(animate);
                                if (controls) {
                                    controls.update();
                                }
                                renderer.render(scene, camera);
                            }
                            animate();
                        }
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        console.log('Loading progress:', percent + '%');
                    },
                    (error) => {
                        console.error('Error loading 3D model:', error);
                        container.innerHTML = '<p style="color: #999; padding: 20px; text-align: center; font-size: 12px;">‚ùå Unable to load 3D model. The file may be corrupted or inaccessible.</p>';
                    }
                );
            } catch (error) {
                console.error('Error initializing 3D viewer:', error);
                container.innerHTML = '<p style="color: red; padding: 20px; text-align: center; font-size: 12px;">‚ùå Error loading 3D viewer: ' + error.message + '</p>';
            }
        }

        addMessage(text, sender) {
            try {
                // Validate container exists
                const container = document.getElementById('custom-chat-messages');
                if (!container) {
                    console.error('‚ùå Chat messages container not found');
                    return;
                }

                // Validate inputs
                if (!text || typeof text !== 'string') {
                    console.error('‚ùå Invalid message text:', typeof text);
                    return;
                }

                if (!sender || !['user', 'bot'].includes(sender)) {
                    console.error('‚ùå Invalid sender:', sender);
                    return;
                }

                // Sanitize text to prevent XSS
                const sanitizedText = String(text)
                    .trim()
                    .substring(0, 5000); // Limit message length

                if (sanitizedText.length === 0) {
                    console.warn('‚ö†Ô∏è Empty message text after sanitization');
                    return;
                }

                const messageDiv = document.createElement('div');
                if (!messageDiv) {
                    console.error('‚ùå Failed to create message div');
                    return;
                }

                messageDiv.className = `custom-chat-message ${sender}-message`;
                
                const bubble = document.createElement('div');
                if (!bubble) {
                    console.error('‚ùå Failed to create bubble');
                    return;
                }

                bubble.className = 'custom-chat-bubble';
                
                const content = document.createElement('div');
                if (!content) {
                    console.error('‚ùå Failed to create content div');
                    return;
                }

                content.className = 'custom-chat-text';
                
                // Format text with proper line breaks and markdown support
                // Use textContent + careful HTML building to prevent XSS
                let formattedText = sanitizedText
                    .split('\n')
                    .map((line, index) => {
                        if (!line || typeof line !== 'string') {
                            return '';
                        }
                        
                        // Escape HTML first
                        line = line
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');
                        
                        // Then apply safe markdown transformations
                        // Convert **bold** to <strong>bold</strong>
                        line = line.replace(/\*\*([^\*]+)\*\*/g, (match, content) => {
                            return '<strong>' + content + '</strong>';
                        });
                        
                        // Convert __italic__ to <em>italic</em>
                        line = line.replace(/__([^_]+)__/g, (match, content) => {
                            return '<em>' + content + '</em>';
                        });
                        
                        return line;
                    })
                    .join('<br>');
                
                // Use safe innerHTML assignment
                try {
                    content.innerHTML = formattedText;
                } catch (e) {
                    console.error('‚ùå Failed to set innerHTML:', e);
                    // Fallback to textContent
                    content.textContent = sanitizedText;
                }
                
                bubble.appendChild(content);
                messageDiv.appendChild(bubble);
                container.appendChild(messageDiv);

                // Auto scroll with error handling
                try {
                    container.scrollTop = container.scrollHeight;
                } catch (e) {
                    console.warn('‚ö†Ô∏è Failed to scroll container:', e);
                }

                // Update badge if minimized
                try {
                    if (sender === 'bot' && this.isMinimized) {
                        this.unreadCount++;
                        this.updateBadge();
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Failed to update badge:', e);
                }

                // Save message to localStorage for persistence
                this.saveChatMessage(sanitizedText, sender);

            } catch (error) {
                console.error('‚ùå Error in addMessage:', error);
            }
        }

        saveChatMessage(text, sender, isHtml = false, metadata = null) {
            // Save individual message to localStorage (supports both text and HTML content)
            // Validates all inputs before saving
            try {
                // Validate inputs
                if (!text || typeof text !== 'string') {
                    console.warn('‚ö†Ô∏è Invalid message text for saving');
                    return;
                }

                if (!sender || !['user', 'bot'].includes(sender)) {
                    console.warn('‚ö†Ô∏è Invalid sender for saving:', sender);
                    return;
                }

                // Load existing messages with error handling
                let messages = [];
                try {
                    const stored = localStorage.getItem('gemini_chat_messages');
                    if (stored && stored.trim() !== '') {
                        messages = JSON.parse(stored);
                        if (!Array.isArray(messages)) {
                            console.warn('‚ö†Ô∏è Stored messages is not an array, resetting');
                            messages = [];
                        }
                    }
                } catch (parseError) {
                    console.error('‚ùå Failed to parse stored messages:', parseError);
                    messages = [];
                }

                // Create message object with all validations
                const messageObj = {
                    text: String(text).substring(0, 5000), // Limit size
                    sender: String(sender),
                    timestamp: Date.now ? new Date().getTime() : Math.floor(Date.now()),
                    isHtml: Boolean(isHtml),
                    metadata: metadata && typeof metadata === 'object' ? metadata : null
                };

                messages.push(messageObj);

                // Prevent localStorage from growing indefinitely
                const MAX_MESSAGES = 500;
                if (messages.length > MAX_MESSAGES) {
                    messages = messages.slice(-MAX_MESSAGES);
                    console.warn(`‚ö†Ô∏è Trimmed messages to last ${MAX_MESSAGES}`);
                }

                // Save with error handling
                localStorage.setItem('gemini_chat_messages', JSON.stringify(messages));

            } catch (e) {
                // Handle quota exceeded and other errors gracefully
                if (e.name === 'QuotaExceededError') {
                    console.error('‚ùå localStorage quota exceeded, clearing old messages');
                    try {
                        localStorage.removeItem('gemini_chat_messages');
                    } catch (clearError) {
                        console.error('‚ùå Failed to clear localStorage:', clearError);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Could not save message to localStorage:', e.message);
                }
            }
        }

        loadMessagesFromStorage() {
            // Load and display saved messages from localStorage
            // LAZY LOADS 3D MODELS - only initializes when scrolled into view
            // Returns: number of messages loaded
            try {
                const messages = JSON.parse(localStorage.getItem('gemini_chat_messages') || '[]');
                
                if (messages.length > 0) {
                    for (const msg of messages) {
                        if (msg.metadata?.type === '3d-model') {
                            // Create placeholder, load on visibility
                            this.createLazy3DModelPlaceholder(msg.metadata.modelUrl, msg.metadata.productName);
                        } else if (msg.metadata?.type === 'multi-3d-model') {
                            // Create placeholder for multi-model, load on visibility
                            try {
                                const savedComponents = JSON.parse(msg.metadata.selectedComponents || '{}');
                                if (Object.keys(savedComponents).length > 0) {
                                    this.selectedComponents = savedComponents;
                                    this.createLazyMultiModel3DPlaceholder();
                                } else {
                                    this.addMessageDirectly('üóÇÔ∏è Your Build - 3D View (click "View Build" to reload)', 'bot');
                                }
                            } catch (e) {
                                console.error('Could not parse selectedComponents:', e);
                                this.addMessageDirectly('üóÇÔ∏è Your Build - 3D View (click "View Build" to reload)', 'bot');
                            }
                        } else if (msg.isHtml) {
                            // Load HTML content (carousels, etc)
                            this.addMessageFromHtml(msg.text, msg.sender);
                        } else {
                            // Load plain text message
                            this.addMessageDirectly(msg.text, msg.sender);
                        }
                    }
                }
                return messages.length;
            } catch (e) {
                console.log('Could not load chat messages:', e);
                return 0;
            }
        }

        createLazy3DModelPlaceholder(modelUrl, productName) {
            /**
             * Create a placeholder for 3D model that only loads when visible
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const modelDiv = document.createElement('div');
            modelDiv.className = 'custom-chat-message bot-message';
            const viewerId = `chat-3d-viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            modelDiv.innerHTML = `
                <div class="custom-chat-bubble product-carousel-bubble" style="max-width: 100%; padding: 12px;">
                    <p style="margin: 0 0 10px 0; font-weight: 600; font-size: 13px; color: #333;">üé¨ ${productName}</p>
                    <div id="${viewerId}" style="width: 100%; height: 280px; background: #eeeeee; border-radius: 6px; position: relative; margin-bottom: 8px; cursor: pointer; pointer-events: auto; touch-action: none; display: flex; align-items: center; justify-content: center; color: #999; font-size: 12px;">Click to load 3D model</div>
                    <p style="margin: 0 0 8px 0; font-size: 11px; color: #666; background: #f0f4ff; padding: 6px 8px; border-radius: 4px;">
                        üñ±Ô∏è Left-click + drag to rotate | Scroll to zoom | Right-click & drag to pan
                    </p>
                    <div style="display: flex; gap: 8px;">
                        <button class="fullscreen-3d-btn" style="flex: 1; padding: 8px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">‚õ∂ Full Screen</button>
                    </div>
                </div>
            `;

            container.appendChild(modelDiv);

            // Setup Intersection Observer for lazy loading
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !entry.target.dataset.loaded) {
                        entry.target.dataset.loaded = 'true';
                        observer.unobserve(entry.target);
                        
                        // Load the 3D model now
                        this.waitForThreeExtensions().then(() => {
                            this.loadChatEmbedded3DModel(viewerId, modelUrl, productName, false);
                        });
                    }
                });
            }, { rootMargin: '100px' });

            observer.observe(modelDiv);

            // Add fullscreen button listener
            modelDiv.querySelector('.fullscreen-3d-btn').addEventListener('click', () => {
                this.openFullscreen3DViewer(modelUrl, productName);
            });
        }

        createLazyMultiModel3DPlaceholder() {
            /**
             * Create a placeholder for multi-model 3D viewer that only loads when visible
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const modelDiv = document.createElement('div');
            modelDiv.className = 'custom-chat-message bot-message';
            const viewerId = `multi-3d-viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            const multiModelHtml = `
                <div class="custom-chat-bubble product-carousel-bubble" style="max-width: 100%; padding: 12px;">
                    <p style="margin: 0 0 10px 0; font-weight: 600; font-size: 13px; color: #333;">Your Build - 3D View</p>
                    <div id="${viewerId}" style="width: 100%; height: 350px; background: #eeeeee; border-radius: 6px; position: relative; margin-bottom: 8px; pointer-events: auto; touch-action: none; display: flex; align-items: center; justify-content: center; color: #999; font-size: 12px;">Click to load 3D models</div>
                    <p style="margin: 0 0 8px 0; font-size: 11px; color: #666; background: #f0f4ff; padding: 6px 8px; border-radius: 4px;">
                        üñ±Ô∏è Left-click + drag to rotate | Scroll to zoom | Right-click & drag to drag models
                    </p>
                    <div style="display: flex; gap: 8px;">
                        <button class="fullscreen-multi-3d-btn" style="flex: 1; padding: 8px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">‚õ∂ Full Screen</button>
                        <button class="continue-after-3d-btn" style="flex: 1; padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600;">Continue with Build</button>
                    </div>
                </div>
            `;
            modelDiv.innerHTML = multiModelHtml;
            container.appendChild(modelDiv);

            // Setup Intersection Observer for lazy loading
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !entry.target.dataset.loaded) {
                        entry.target.dataset.loaded = 'true';
                        observer.unobserve(entry.target);
                        
                        // Load the multi-model viewer now
                        this.waitForThreeExtensions().then(() => {
                            this.loadMultiModel3DViewer(viewerId);
                        });
                    }
                });
            }, { rootMargin: '100px' });

            observer.observe(modelDiv);

            // Add fullscreen button listener
            modelDiv.querySelector('.fullscreen-multi-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.openFullscreenMultiModel3D();
            });

            // Add continue button listener
            modelDiv.querySelector('.continue-after-3d-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.addMessage('Ready to finalize your build?', 'user');
                setTimeout(() => {
                    this.showBuildFinishOptions();
                }, 500);
            });
        }

        addMessageFromHtml(htmlContent, sender) {
            // Add message with HTML content (for carousels, 3D models, etc)
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `custom-chat-message ${sender}-message`;
            messageDiv.innerHTML = htmlContent;
            container.appendChild(messageDiv);

            // Auto scroll
            container.scrollTop = container.scrollHeight;
        }

        addMessageDirectly(text, sender) {
            // Add message without saving again (used for loading from localStorage)
            // IMPORTANT: Apply formatting like addMessage() does
            const container = document.getElementById('custom-chat-messages');
            if (!container) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `custom-chat-message ${sender}-message`;
            
            const bubble = document.createElement('div');
            bubble.className = 'custom-chat-bubble';
            
            const content = document.createElement('div');
            content.className = 'custom-chat-text';
            
            // Format text with proper line breaks and markdown support (SAME AS addMessage)
            let formattedText = text
                .split('\n')
                .map(line => {
                    // Convert **bold** to <strong>bold</strong>
                    line = line.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                    // Convert __italic__ to <em>italic</em>
                    line = line.replace(/__([^_]+)__/g, '<em>$1</em>');
                    return line;
                })
                .join('<br>');
            
            content.innerHTML = formattedText;
            bubble.appendChild(content);
            
            messageDiv.appendChild(bubble);
            container.appendChild(messageDiv);

            // Auto scroll
            container.scrollTop = container.scrollHeight;
        }

        async displayProductCarousel(products, queryDescription) {
            /**
             * Display products in a carousel/card format
             * Saves HTML to localStorage so carousel persists on page refresh
             */
            const container = document.getElementById('custom-chat-messages');
            if (!container || !products || products.length === 0) return;

            const carouselDiv = document.createElement('div');
            carouselDiv.className = 'custom-chat-message bot-message';
            const carouselHtml = `
                <div class="custom-chat-bubble product-carousel-bubble">
                    <p class="carousel-title">${queryDescription || 'Here are some great options for you:'}</p>
                    <div class="product-carousel">
                        ${products.map((product, index) => `
                            <div class="product-card" data-product-id="${product.id}">
                                <div class="product-image">
                                    <img src="${product.image_url}" alt="${product.name}" onerror="this.src='/static/images/placeholder.png'">
                                </div>
                                <div class="product-info">
                                    <h4 class="product-name">${product.name}</h4>
                                    <p class="product-category">${product.category}</p>
                                    <p class="product-price">‚Ç±${parseFloat(product.price).toLocaleString('en-PH', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</p>
                                    <p class="product-description">${product.description.substring(0, 60)}${product.description.length > 60 ? '...' : ''}</p>
                                    <a href="/product_item/${product.id}/" class="product-link" target="_blank">View Details ‚Üí</a>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <p class="carousel-note">Click "View Details" to see full specifications and availability</p>
                </div>
            `;
            carouselDiv.innerHTML = carouselHtml;

            container.appendChild(carouselDiv);
            container.scrollTop = container.scrollHeight;

            // Save carousel HTML to localStorage for persistence on refresh
            this.saveChatMessage(carouselHtml, 'bot', true);

            // Update badge if minimized
            if (this.isMinimized) {
                this.unreadCount++;
                this.updateBadge();
            }
        }

        async searchAndDisplayProducts(paramsString) {
            /**
             * Search products using API parameters and automatically display in carousel
             * Validates all inputs and handles errors gracefully
             */
            try {
                // Validate params string
                if (!paramsString || typeof paramsString !== 'string') {
                    console.error('‚ùå Invalid params string:', typeof paramsString);
                    this.addMessage('Invalid search parameters. Please try again.', 'bot');
                    return;
                }

                const url = `/api/products/recommend/?${paramsString}`;
                
                // Validate URL
                if (!url || url.length === 0) {
                    console.error('‚ùå Invalid URL constructed');
                    return;
                }

                console.log('üîç Searching:', url);

                // Fetch with timeout
                const response = await fetch(url, {
                    signal: AbortSignal.timeout(15000) // 15 second timeout for search
                });
                
                // Validate response object
                if (!response) {
                    console.error('‚ùå No response received');
                    this.addMessage('No response from server. Please try again.', 'bot');
                    return;
                }

                if (response.ok) {
                    // Parse response with error handling
                    let data;
                    try {
                        data = await response.json();
                    } catch (parseError) {
                        console.error('‚ùå Failed to parse search response:', parseError);
                        this.addMessage('Invalid response format. Please try again.', 'bot');
                        return;
                    }

                    // Validate data structure
                    if (!data || typeof data !== 'object') {
                        console.error('‚ùå Invalid data object');
                        this.addMessage('Invalid response data. Please try again.', 'bot');
                        return;
                    }

                    // Check for API errors
                    if (data.error) {
                        console.error('API error:', data.error);
                        this.addMessage(`Error: ${data.error}`, 'bot');
                        return;
                    }

                    // Validate products array
                    if (data.success && data.products && Array.isArray(data.products) && data.products.length > 0) {
                        // Extract query from params for display
                        const params = new URLSearchParams(paramsString);
                        const query = params.get('query') || 'Products';
                        
                        // Validate query string
                        if (!query || typeof query !== 'string') {
                            console.error('‚ùå Invalid query:', query);
                            return;
                        }

                        const description = `${data.count || data.products.length} ${String(query).trim()}(s) found:`;
                        
                        console.log(`‚úÖ Found ${data.products.length} products`);

                        // Display carousel with error handling
                        this.displayProductCarousel(data.products, description);
                    } else if (data.success === false || !data.products || data.products.length === 0) {
                        this.addMessage('üòî Sorry, no products found matching your criteria. Try different search terms or visit our store!', 'bot');
                    } else {
                        console.error('‚ùå Unexpected response structure:', data);
                        this.addMessage('Could not process search results. Please try again.', 'bot');
                    }
                } else {
                    // Handle different HTTP error codes
                    if (response.status === 404) {
                        this.addMessage('Search service not available. Please try again.', 'bot');
                    } else if (response.status === 429) {
                        this.addMessage('Too many search requests. Please wait a moment.', 'bot');
                    } else if (response.status === 500) {
                        this.addMessage('Server error. Please try again later.', 'bot');
                    } else {
                        this.addMessage(`Search error (${response.status}). Please try again.`, 'bot');
                    }

                    try {
                        const errorData = await response.json();
                        console.error('API error response:', errorData);
                    } catch (e) {
                        console.error('HTTP ' + response.status + ' response received');
                    }
                }
            } catch (error) {
                console.error('‚ùå Error in searchAndDisplayProducts:', error);
                
                if (error.name === 'AbortError') {
                    this.addMessage('Search timed out. Please try again.', 'bot');
                } else if (error.message && error.message.includes('Network')) {
                    this.addMessage('Network error. Please check your connection.', 'bot');
                } else {
                    this.addMessage('Error loading products. Please try again.', 'bot');
                }
            }
        }

        async searchAndRecommendProducts(query, component = null) {
            /**
             * Search for products using the recommendation API
             * Returns matching products from store inventory
             * Validates all inputs before using
             */
            try {
                // Validate query
                if (!query || typeof query !== 'string') {
                    console.error('‚ùå Invalid query:', typeof query);
                    return {
                        success: false,
                        products: [],
                        count: 0
                    };
                }

                const queryEncoded = encodeURIComponent(String(query).substring(0, 100).trim());
                let url = `/api/products/recommend/?query=${queryEncoded}&max_results=6`;
                
                if (component && typeof component === 'string') {
                    const componentEncoded = encodeURIComponent(String(component).substring(0, 100).trim());
                    url += `&component=${componentEncoded}`;
                }

                console.log('Searching products:', url);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(15000)
                });

                // Validate response
                if (!response) {
                    console.error('‚ùå No response from product search');
                    return {
                        success: false,
                        products: [],
                        count: 0
                    };
                }

                if (response.ok) {
                    let data;
                    try {
                        data = await response.json();
                    } catch (parseError) {
                        console.error('‚ùå Failed to parse product search response:', parseError);
                        return {
                            success: false,
                            products: [],
                            count: 0
                        };
                    }

                    // Validate response structure
                    if (data.success && data.products && Array.isArray(data.products) && data.products.length > 0) {
                        console.log(`‚úÖ Found ${data.products.length} products`);
                        return {
                            success: true,
                            products: data.products,
                            count: data.count || data.products.length
                        };
                    }
                } else {
                    console.error(`Search failed with status ${response.status}`);
                }
            } catch (error) {
                console.error('‚ùå Error searching products:', error.message);
            }

            return {
                success: false,
                products: [],
                count: 0
            };
        }

        showTypingIndicator() {
            try {
                const container = document.getElementById('custom-chat-messages');
                if (!container) {
                    console.error('‚ùå Chat container not found');
                    return;
                }

                const indicatorDiv = document.createElement('div');
                if (!indicatorDiv) {
                    console.error('‚ùå Failed to create indicator div');
                    return;
                }

                indicatorDiv.className = 'custom-chat-message bot-message';
                indicatorDiv.id = 'typing-indicator';
                
                const bubble = document.createElement('div');
                if (!bubble) {
                    console.error('‚ùå Failed to create bubble');
                    return;
                }

                bubble.className = 'custom-chat-bubble typing-bubble';
                bubble.innerHTML = '<span></span><span></span><span></span>';
                
                indicatorDiv.appendChild(bubble);
                container.appendChild(indicatorDiv);
                
                container.scrollTop = container.scrollHeight;
            } catch (error) {
                console.error('‚ùå Error showing typing indicator:', error);
            }
        }

        hideTypingIndicator() {
            try {
                const indicator = document.getElementById('typing-indicator');
                if (indicator && indicator.parentNode) {
                    indicator.remove();
                }
            } catch (error) {
                console.error('‚ö†Ô∏è Error hiding typing indicator:', error);
            }
        }

        updateBadge() {
            try {
                const badge = document.getElementById('custom-chat-badge');
                if (!badge) {
                    console.warn('‚ö†Ô∏è Badge element not found');
                    return;
                }

                if (this.unreadCount && this.unreadCount > 0) {
                    badge.textContent = String(this.unreadCount);
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error updating badge:', error);
            }
        }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            window.customBotpressChat = new GeminiChat();
        });
    } else {
        window.customBotpressChat = new GeminiChat();
    }
</script>

<script>

    async function loadAndShow3DModel(productId) {
        try {
            // Fetch product 3D model data from Django API
            const response = await fetch(`/api/product/${productId}/3d/`);
            const data = await response.json();
            
            if (data.success && data.has_model) {
                console.log('3D Model loaded:', data.product_name);
                openModal3DViewerWithModel(data);
            } else {
                console.log('Product has no 3D model');
                if (typeof window.botpressWebChat !== 'undefined') {
                    window.botpressWebChat.sendMessage('Sorry, this product does not have a 3D model available.');
                }
            }
        } catch (error) {
            console.error('Error loading 3D model:', error);
            if (typeof window.botpressWebChat !== 'undefined') {
                window.botpressWebChat.sendMessage('Error loading 3D model. Please try again.');
            }
        }
    }

    function openModal3DViewerWithModel(productData) {
        let modal = document.getElementById('modal-3d-viewer-botpress');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'modal-3d-viewer-botpress';
            modal.className = 'modal-3d-viewer';
            document.body.appendChild(modal);

            modal.addEventListener('click', function(e) {
                if (e.target === modal || e.target.classList.contains('modal-3d-close')) {
                    modal.classList.remove('active');
                }
            });
        }

        // Update modal with product and model data
        modal.innerHTML = `
            <div class="modal-3d-content">
                <div class="modal-3d-header">
                    <h2>üéÆ ${productData.product_name}</h2>
                    <button class="modal-3d-close">&times;</button>
                </div>
                <div class="modal-3d-body">
                    <p><strong>Brand:</strong> ${productData.brand}</p>
                    <p><strong>Price:</strong> ‚Ç±${parseFloat(productData.price).toLocaleString('en-US', {minimumFractionDigits: 2})}</p>
                    <p><strong>Type:</strong> ${productData.component_type.toUpperCase()}</p>
                    ${productData.description ? `<p><strong>Description:</strong> ${productData.description}</p>` : ''}
                    
                    <div style="margin-top: 15px; padding: 15px; background: #f0f4ff; border-radius: 8px; border-left: 4px solid #667eea;">
                        <p style="margin: 0; font-size: 13px; color: #555;">
                            üñ±Ô∏è <strong>Controls:</strong><br>
                            ‚Ä¢ Left-click + drag to rotate<br>
                            ‚Ä¢ Scroll to zoom<br>
                            ‚Ä¢ Right-click + drag to pan
                        </p>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <a href="/product_item/${productData.product_id}/" class="btn-sm" style="padding: 10px 15px; background: #667eea; color: white; text-decoration: none; border-radius: 5px; flex: 1; text-align: center;">View Details</a>
                        <button onclick="addProductToCart(${productData.product_id})" class="btn-sm" style="padding: 10px 15px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; flex: 1;">Add to Cart</button>
                    </div>
                </div>
            </div>
        `;

        modal.classList.add('active');
    }

    function addProductToCart(productId) {
        fetch(`/add-to-cart/${productId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken'),
            },
            body: JSON.stringify({ quantity: 1 })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (typeof window.botpressWebChat !== 'undefined') {
                window.botpressWebChat.sendMessage('‚úÖ Product added to cart!');
            }
        })
        .catch(error => {
            console.error('Error adding to cart:', error);
            if (typeof window.botpressWebChat !== 'undefined') {
                window.botpressWebChat.sendMessage('Error adding product to cart.');
            }
        });
    }

    console.log('Script tag loaded');
    document.addEventListener('DOMContentLoaded', function () {
        console.log('DOMContentLoaded event fired!');
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    cookie = cookie.trim();
                    if (cookie.startsWith(name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // Helper function to get current filter values
        function getFilterValues() {
            const searchInput = document.querySelector('.search-form input[name="search"]');
            const categorySelect = document.getElementById("categorySelect");
            const brandItems = document.querySelectorAll("#brand_filter li.selected");
            
            return {
                search: searchInput ? searchInput.value : '',
                category: categorySelect ? categorySelect.value : '',
                brand: brandItems.length > 0 ? brandItems[0].dataset.id : ''
            };
        }

        // Add to cart (AJAX fallback) - buttons still submit forms for graceful degradation
        const cartButtons = document.querySelectorAll('.add-to-cart-btn');
        console.log('Found ' + cartButtons.length + ' add-to-cart buttons');
        cartButtons.forEach((btn, index) => {
            btn.addEventListener('click', function (e) {
                e.preventDefault();
                const productId = this.dataset.productId;
                
                console.log('Add to cart button clicked, Product ID:', productId);
                console.log('CSRF Token:', csrftoken);
                
                if (!productId) {
                    console.error('Product ID not found');
                    alert('Error: Product ID not found');
                    return;
                }
                
                if (!csrftoken) {
                    console.error('CSRF Token not found');
                    alert('Error: Security token missing. Please refresh the page.');
                    return;
                }

                fetch(`/add-to-cart/${productId}`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrftoken,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ quantity: 1 })
                })
                .then(response => {
                    // Check if response is valid
                    if (!response.ok) {
                        console.error(`HTTP Error: ${response.status} ${response.statusText}`);
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    // Check content type before parsing JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        console.error('Invalid response format:', contentType);
                        throw new Error('Invalid response format: expected JSON');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Add to cart response:', data);
                    if (data.error) {
                        console.error('Error adding to cart:', data.error);
                        alert('Failed to add to cart: ' + data.error);
                        return;
                    }
                    
                    const cartCountElement = document.getElementById('cart-count');
                    if (cartCountElement && data.cart_count) {
                        cartCountElement.textContent = data.cart_count;
                    }
                    
                    const popup = document.getElementById('cart-popup');
                    if (popup) {
                        popup.classList.add('show');
                        setTimeout(() => popup.classList.remove('show'), 2200);
                    }
                    
                    console.log('Product added to cart successfully!');
                })
                .catch(error => {
                    console.error('Error adding to cart:', error);
                    alert(`Error: ${error.message}`);
                });
            });
        });

        try {
            // FILTER PANEL INITIALIZATION
            const filterBtn = document.getElementById('filterToggle');
            const filterPanel = document.getElementById('filterPanel');
            const closeBtn = document.getElementById('filterClose');
            const overlayDiv = document.querySelector('.filter-panel-overlay');
            const mainFilterForm = document.getElementById('mainFilterForm');
            const categorySelect = document.getElementById('categorySelect');
            const brandItems = document.querySelectorAll('.brand-item');
            const clearBrandFilter = document.getElementById('clearBrandFilter');
            const resetFiltersBtn = document.getElementById('resetFilters');

            // Open filter panel
            if (filterBtn && filterPanel) {
                filterBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    filterPanel.classList.add('open');
                    document.body.style.overflow = 'hidden';
                });
            }

            // Close filter panel
            const closeFilterPanel = function() {
                if (filterPanel) {
                    filterPanel.classList.remove('open');
                    document.body.style.overflow = '';
                }
            };

            if (closeBtn) {
                closeBtn.addEventListener('click', closeFilterPanel);
            }

            // Close on overlay click
            if (overlayDiv) {
                overlayDiv.addEventListener('click', closeFilterPanel);
            }

            // Close on ESC key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && filterPanel && filterPanel.classList.contains('open')) {
                    closeFilterPanel();
                }
            });

            // Category filter change
            if (categorySelect) {
                categorySelect.addEventListener('change', function() {
                    if (mainFilterForm) {
                        mainFilterForm.submit();
                    }
                });
            }

            // Brand item selection
            brandItems.forEach(function(item) {
                item.addEventListener('click', function(e) {
                    if (e.target.classList.contains('brand-checkbox')) {
                        return;
                    }
                    e.preventDefault();
                    const checkbox = item.querySelector('.brand-checkbox');
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        const brandId = item.dataset.id;
                        
                        if (checkbox.checked) {
                            item.classList.add('selected');
                            const hiddenInput = document.createElement('input');
                            hiddenInput.type = 'hidden';
                            hiddenInput.name = 'brand';
                            hiddenInput.value = brandId;
                            mainFilterForm.appendChild(hiddenInput);
                            if (clearBrandFilter) clearBrandFilter.style.display = 'inline-block';
                        } else {
                            item.classList.remove('selected');
                            const hiddenInput = mainFilterForm.querySelector('input[name="brand"]');
                            if (hiddenInput) hiddenInput.remove();
                            if (clearBrandFilter) clearBrandFilter.style.display = 'none';
                        }
                    }
                });
            });

            // Clear brand filter
            if (clearBrandFilter) {
                clearBrandFilter.addEventListener('click', function(e) {
                    e.preventDefault();
                    brandItems.forEach(function(item) {
                        item.classList.remove('selected');
                        const checkbox = item.querySelector('.brand-checkbox');
                        if (checkbox) checkbox.checked = false;
                    });
                    const hiddenInput = mainFilterForm.querySelector('input[name="brand"]');
                    if (hiddenInput) hiddenInput.remove();
                    clearBrandFilter.style.display = 'none';
                });
            }

            // Reset all filters
            if (resetFiltersBtn) {
                resetFiltersBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    categorySelect.value = '';
                    brandItems.forEach(function(item) {
                        item.classList.remove('selected');
                        const checkbox = item.querySelector('.brand-checkbox');
                        if (checkbox) checkbox.checked = false;
                    });
                    const hiddenInput = mainFilterForm.querySelector('input[name="brand"]');
                    if (hiddenInput) hiddenInput.remove();
                    if (clearBrandFilter) clearBrandFilter.style.display = 'none';
                });
            }

            // SORT DROPDOWN
            var sortSelect = document.getElementById('priceOrder');
            var searchForm = document.getElementById('searchForm');
            if (sortSelect && searchForm) {
                sortSelect.onchange = function() {
                    if (this.value) {
                        var input = searchForm.querySelector('input[name="price_order"]');
                        if (input) input.value = this.value;
                        searchForm.submit();
                    }
                };
            }
            
            console.log('Filter setup complete');
        } catch(e) {
            console.error('Filter setup error:', e);
        }
        
        document.addEventListener('click', function(e) {
            const favBtn = e.target.closest('.favorite_btn');
            if (favBtn && favBtn.dataset.productId) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);
        
        console.log('DOMContentLoaded setup complete!');
    });

</script>

<style>
    /* ===== Product Page Layout ===== */
    .productpage {
        position: relative;
        display: block;
        top: 0;
        padding: 2rem 1rem 6rem;
        background: transparent;
        margin-top: 0;
        max-width: 1400px;
        margin-left: auto;
        margin-right: auto;
    }

    .product-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        max-width: 1200px;
        margin: 0 auto 1rem;
        padding: 0;
        flex-wrap: wrap;
        margin-bottom: 0.8rem;
    }

    .product-title {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .product-title h1 {
        font-size: 1.8rem;
        margin: 0;
        color: #0b3b50;
        font-weight: 700;
    }

    .product-title p {
        margin: 0;
        color: #6b7782;
        font-size: 0.95rem;
    }

    .product-title .muted {
        color: #6b7782;
        font-size: 0.85rem;
        margin-top: 0.2rem;
    }

    .products-main {
        max-width: 1200px;
        margin: 0 auto;
    }

    .product-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }

    /* ===== Product Controls & Filter Styles ===== */
    .product-controls {
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 24px;
    }

    .search-form {
        flex: 1;
        min-width: 250px;
        display: flex;
        position: relative;
    }

    .search-form input {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.3s ease;
        font-family: inherit;
    }

    .search-form input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        background: #f8f9ff;
    }

    .controls-right {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
    }

    .sort-wrapper {
        position: relative;
        display: flex;
        align-items: center;
    }

    .sort-dropdown {
        padding: 12px 16px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        background: white;
        font-size: 14px;
        font-weight: 500;
        color: #333;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        appearance: none;
        padding-right: 36px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23667eea' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-color: white;
    }

    .sort-dropdown:hover {
        border-color: #667eea;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
    }

    .sort-dropdown:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        background-color: #f8f9ff;
    }

    .filter-btn {
        padding: 12px 18px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: inherit;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        position: relative;
        z-index: 100;
    }

    .filter-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
    }

    .filter-btn:active {
        transform: translateY(0);
    }

    /* Filter Panel Improvements */
    /* Filter Panel Styles */
    .filter-panel {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        z-index: 999;
        display: flex;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .filter-panel.open {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
    }

    .filter-panel-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(3px);
        cursor: pointer;
    }

    .filter-panel-inner {
        position: relative;
        width: 100%;
        max-width: 360px;
        background: white;
        height: 100vh;
        overflow-y: auto;
        padding: 0;
        box-shadow: -4px 0 30px rgba(0, 0, 0, 0.25);
        transform: translateX(-100%);
        transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
    }

    .filter-panel.open .filter-panel-inner {
        transform: translateX(0);
    }

    .filter-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 2px solid #f0f2f7;
        background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
        flex-shrink: 0;
    }

    .filter-panel-title {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        color: #033F63;
        letter-spacing: -0.5px;
    }

    .filter-close-btn {
        background: transparent;
        border: none;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 24px;
        color: #667eea;
        transition: all 0.2s ease;
        flex-shrink: 0;
    }

    .filter-close-btn:hover {
        background: rgba(102, 126, 234, 0.1);
        color: #033F63;
        transform: rotate(90deg);
    }

    .filter-close-btn:active {
        transform: rotate(90deg) scale(0.95);
    }

    .filter-form {
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow-y: auto;
        padding: 20px 24px;
        gap: 24px;
    }

    .filter-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .filter-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .filter-label {
        font-weight: 700;
        color: #033F63;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0;
    }

    .clear-filter-btn {
        background: none;
        border: none;
        color: #667eea;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        text-transform: uppercase;
        padding: 2px 8px;
        border-radius: 3px;
        transition: all 0.2s ease;
    }

    .clear-filter-btn:hover {
        background: rgba(102, 126, 234, 0.1);
        color: #764ba2;
    }

    .filter-select {
        padding: 12px 14px;
        border: 2px solid #e0e6ff;
        border-radius: 8px;
        background: white;
        font-size: 14px;
        color: #333;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
        font-weight: 500;
    }

    .filter-select:hover {
        border-color: #667eea;
        background: #f8f9ff;
    }

    .filter-select:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.12);
    }

    /* Brand List Styles */
    .brand-list-wrapper {
        display: flex;
        flex-direction: column;
        max-height: 300px;
        overflow-y: auto;
        border: 2px solid #e0e6ff;
        border-radius: 8px;
        background: #fafbff;
        padding: 8px;
    }

    .brand-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .brand-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 11px 12px;
        border: 2px solid transparent;
        border-radius: 6px;
        background: white;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 13px;
        color: #333;
        font-weight: 500;
        user-select: none;
    }

    .brand-item:hover {
        border-color: #667eea;
        background: #f8f9ff;
        transform: translateX(2px);
    }

    .brand-item.selected {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: transparent;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .brand-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #667eea;
        flex-shrink: 0;
    }

    .brand-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Filter Actions */
    .filter-actions {
        display: flex;
        gap: 10px;
        padding: 20px 24px;
        border-top: 2px solid #f0f2f7;
        background: #f8f9ff;
        flex-shrink: 0;
        margin-top: auto;
    }

    .filter-apply-btn,
    .filter-reset-btn {
        flex: 1;
        padding: 12px 16px;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-family: inherit;
    }

    .filter-apply-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .filter-apply-btn:hover {
        box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        transform: translateY(-1px);
    }

    .filter-apply-btn:active {
        transform: translateY(0);
    }

    .filter-reset-btn {
        background: white;
        color: #667eea;
        border: 2px solid #e0e6ff;
    }

    .filter-reset-btn:hover {
        background: #f8f9ff;
        border-color: #667eea;
        color: #764ba2;
    }

    .filter-reset-btn:active {
        transform: scale(0.98);
    }

    @media (max-width: 768px) {
        .product-grid {
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.75rem;
        }

        .product-card {
            flex: 1 1 auto;
            border-radius: 10px;
        }

        .product-image {
            height: 150px;
        }

        .card-body {
            padding: 10px;
        }

        .card-title {
            font-size: 0.9rem;
        }

        .price {
            font-size: 0.9rem;
        }

        .product-controls {
            flex-direction: column;
            gap: 12px;
        }

        .search-form {
            min-width: 100%;
        }

        .controls-right {
            width: 100%;
            justify-content: space-between;
        }

        .sort-dropdown,
        .filter-btn {
            flex: 1;
        }

        .filter-panel-inner {
            max-width: 100%;
            width: 85vw;
        }
    }

    @media (max-width: 480px) {
        .product-grid {
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        .product-card {
            border-radius: 8px;
        }

        .product-image {
            height: 140px;
        }

        .card-title {
            font-size: 0.85rem;
        }

        .price {
            font-size: 0.85rem;
        }

        .sort-dropdown {
            font-size: 13px;
            padding: 10px 14px;
            padding-right: 32px;
        }

        .filter-btn {
            padding: 10px 14px;
            font-size: 13px;
        }

        .filter-panel-inner {
            width: 90vw;
            padding: 16px;
        }
    }
    .custom-chat-toggle {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: #033F63;
        color: white;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        box-shadow: 0 4px 12px rgba(3, 63, 99, 0.3);
        transition: all 0.3s ease;
        z-index: 1000;
    }

    .custom-chat-toggle:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 16px rgba(3, 63, 99, 0.4);
    }

    .custom-chat-toggle.active {
        transform: scale(1.1);
    }

    .custom-chat-badge {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ff4757;
        color: white;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(255, 71, 87, 0.4);
    }

    .custom-chat-widget {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 85vw;
        max-width: 1100px;
        height: 85vh;
        max-height: 800px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        transition: all 0.3s ease;
        z-index: 1001;
        will-change: transform, opacity;
    }

    .custom-chat-widget.hidden {
        opacity: 0;
        visibility: hidden;
        transform: translateY(20px) scale(0.9);
        pointer-events: none;
    }

    .custom-chat-widget.minimized {
        height: auto;
        max-height: 60px;
    }

    .custom-chat-widget.minimized .custom-chat-messages,
    .custom-chat-widget.minimized .custom-chat-input-area {
        display: none;
    }

    .custom-chat-header {
        padding: 20px 24px;
        background: #033F63;
        color: white;
        border-radius: 16px 16px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        gap: 12px;
        box-shadow: 0 4px 15px rgba(3, 63, 99, 0.3);
    }

    .custom-chat-header-content {
        flex: 1;
    }

    .custom-chat-title {
        margin: 0 0 4px 0;
        font-size: 18px;
        font-weight: 700;
        line-height: 1.3;
    }

    .custom-chat-subtitle {
        margin: 0;
        font-size: 13px;
        opacity: 0.85;
    }

    .custom-chat-header-actions {
        display: flex;
        gap: 10px;
    }

    .custom-chat-icon-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 18px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
    }

    .custom-chat-icon-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
    }

    .custom-chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px 24px;
        background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
        display: flex;
        flex-direction: column;
        gap: 14px;
    }

    .custom-chat-messages::-webkit-scrollbar {
        width: 8px;
    }

    .custom-chat-messages::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
    }

    .custom-chat-messages::-webkit-scrollbar-thumb {
        background: #c0c0c0;
        border-radius: 4px;
    }

    .custom-chat-messages::-webkit-scrollbar-thumb:hover {
        background: #a0a0a0;
    }

    .custom-chat-message {
        display: flex;
        animation: slideIn 0.3s ease;
    }

    .user-message {
        justify-content: flex-end;
    }

    .bot-message {
        justify-content: flex-start;
    }

    .custom-chat-bubble {
        padding: 12px 16px;
        border-radius: 14px;
        max-width: 85%;
        word-wrap: break-word;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .user-message .custom-chat-bubble {
        background: #0B76AF;
        color: white;
        border-radius: 14px 0 14px 14px;
    }

    .bot-message .custom-chat-bubble {
        background: white;
        color: #333;
        border-left: 4px solid #0B76AF;
        border-radius: 0 14px 14px 14px;
    }

    .custom-chat-text {
        margin: 0;
        font-size: 14px;
        line-height: 1.5;
    }

    /* Carousel Styles */
    .carousel-container {
        display: flex;
        gap: 12px;
        overflow-x: auto;
        padding: 4px 0;
        scroll-behavior: smooth;
    }

    .carousel-container::-webkit-scrollbar {
        height: 6px;
    }

    .carousel-container::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 3px;
    }

    .carousel-container::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 3px;
    }

    .carousel-container::-webkit-scrollbar-thumb:hover {
        background: #a0a0a0;
    }

    .carousel-card {
        flex: 0 0 280px;
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        border: 1px solid #eee;
        display: flex;
        flex-direction: column;
    }

    .carousel-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.2);
        border-color: #667eea;
    }

    .carousel-card-image {
        width: 100%;
        height: 180px;
        overflow: hidden;
        background: #f0f0f0;
    }

    .carousel-card-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.3s ease;
    }

    .carousel-card:hover .carousel-card-image img {
        transform: scale(1.05);
    }

    .carousel-card-content {
        padding: 14px;
        flex: 1;
        display: flex;
        flex-direction: column;
    }

    .carousel-card-title {
        margin: 0 0 6px 0;
        font-size: 15px;
        font-weight: 700;
        color: #333;
        line-height: 1.3;
    }

    .carousel-card-subtitle {
        margin: 0;
        font-size: 12px;
        color: #666;
        line-height: 1.4;
        flex: 1;
    }

    .carousel-card-actions {
        padding: 0 14px 14px 14px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }

    .carousel-card-btn {
        flex: 1;
        min-width: 100px;
        padding: 8px 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        text-decoration: none;
        text-align: center;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .carousel-card-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .carousel-card-btn:active {
        transform: translateY(0);
    }

    .typing-bubble {
        display: flex;
        gap: 4px;
        align-items: center;
        padding: 12px 16px;
    }

    .typing-bubble span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #667eea;
        animation: typing 1.4s infinite;
    }

    .typing-bubble span:nth-child(2) {
        animation-delay: 0.2s;
    }

    .typing-bubble span:nth-child(3) {
        animation-delay: 0.4s;
    }

    @keyframes typing {
        0%, 60%, 100% {
            opacity: 0.5;
            transform: translateY(0);
        }
        30% {
            opacity: 1;
            transform: translateY(-8px);
        }
    }

    /* Product Carousel Styles for Chat */
    .product-carousel-bubble {
        max-width: 100%;
        padding: 12px !important;
        background: #f8f9fa !important;
        border: 1px solid #e0e0e0 !important;
    }

    .carousel-title {
        margin: 0 0 12px 0 !important;
        font-weight: 600;
        font-size: 14px;
        color: #333;
    }

    .product-carousel {
        display: flex;
        gap: 12px;
        overflow-x: auto;
        padding: 8px 0;
        margin: 12px 0;
        scroll-behavior: smooth;
    }

    .product-carousel::-webkit-scrollbar {
        height: 6px;
    }

    .product-carousel::-webkit-scrollbar-track {
        background: transparent;
    }

    .product-carousel::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 3px;
    }

    .product-carousel::-webkit-scrollbar-thumb:hover {
        background: #999;
    }

    .product-card {
        flex: 0 0 200px;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid #ddd;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .product-card-build {
        background: white;
        border-radius: 6px;
        overflow: hidden;
        border: 1px solid #ddd;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .product-card-build:hover {
        border-color: #667eea;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        transform: translateY(-2px);
    }

    .product-card:hover {
        border-color: #667eea;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        transform: translateY(-2px);
    }

    .product-image {
        width: 100%;
        height: 140px;
        overflow: hidden;
        background: #f5f5f5;
    }

    .product-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.3s ease;
    }

    .product-card:hover .product-image img {
        transform: scale(1.05);
    }

    .product-info {
        padding: 10px;
        display: flex;
        flex-direction: column;
        flex-grow: 1;
    }

    .product-name {
        margin: 0 0 4px 0;
        font-size: 13px;
        font-weight: 600;
        color: #333;
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    .product-category {
        margin: 0 0 4px 0;
        font-size: 11px;
        color: #999;
        font-weight: 500;
    }

    .product-price {
        margin: 0 0 6px 0;
        font-size: 14px;
        font-weight: 700;
        color: #667eea;
    }

    .product-description {
        margin: 0 0 8px 0;
        font-size: 11px;
        color: #666;
        line-height: 1.3;
        flex-grow: 1;
    }

    .product-link {
        display: inline-block;
        padding: 6px 10px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-decoration: none;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease;
        cursor: pointer;
    }

    .product-link:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .carousel-note {
        margin: 8px 0 0 0 !important;
        font-size: 11px;
        color: #999;
        font-style: italic;
        text-align: center;
    }

    .custom-chat-input-area {
        display: flex;
        gap: 8px;
        padding: 12px 20px;
        background: white;
        border-top: 1px solid #e0e0e0;
        border-radius: 0 0 12px 12px;
        flex-shrink: 0;
    }

    .custom-chat-input {
        flex: 1;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 14px;
        font-family: inherit;
        transition: all 0.3s;
        outline: none;
    }

    .custom-chat-input:focus {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .custom-chat-input::placeholder {
        color: #999;
    }

    .custom-chat-send-btn {
        width: 38px;
        height: 38px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        transition: all 0.3s;
        flex-shrink: 0;
    }

    .custom-chat-send-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .custom-chat-send-btn:active {
        transform: translateY(0);
    }

    /* Quick Actions Styles */
    .custom-chat-quick-actions {
        padding: 12px 16px;
        background: #f8f9fa;
        border-top: 1px solid #e0e0e0;
        border-bottom: 1px solid #e0e0e0;
        flex-shrink: 0;
    }

    .custom-chat-quick-btn {
        background: white;
        border: 1px solid #ddd;
        color: #333;
        padding: 10px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.3s;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .custom-chat-quick-btn:hover {
        background: #033F63;
        color: white;
        border-color: #033F63;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(3, 63, 99, 0.3);
    }

    .custom-chat-quick-btn:active {
        transform: translateY(0);
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Responsive */
    @media (max-width: 1024px) {
        .custom-chat-widget {
            width: 75vw;
            height: 80vh;
        }

        .carousel-card {
            flex: 0 0 240px;
        }
    }

    @media (max-width: 768px) {
        .custom-chat-widget {
            width: 90vw;
            height: 85vh;
            bottom: 20px;
            right: 20px;
            max-width: none;
            max-height: none;
        }

        .custom-chat-toggle {
            bottom: 15px;
            right: 15px;
            width: 55px;
            height: 55px;
            font-size: 22px;
        }

        .custom-chat-bubble {
            max-width: 95%;
        }

        .carousel-card {
            flex: 0 0 200px;
        }

        .custom-chat-header {
            padding: 16px 18px;
        }

        .custom-chat-messages {
            padding: 16px 18px;
        }

        .custom-chat-input-area {
            padding: 10px 18px;
        }
    }

    @media (max-width: 480px) {
        .custom-chat-widget {
            width: calc(100% - 20px);
            height: calc(100vh - 100px);
            bottom: 50px;
            right: 10px;
            left: 10px;
            border-radius: 12px;
        }

        .custom-chat-toggle {
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .custom-chat-bubble {
            max-width: 95%;
            padding: 10px 14px;
            font-size: 13px;
        }

        .build-finish-buttons {
            grid-template-columns: 1fr !important;
            gap: 8px !important;
        }

        .build-finish-buttons button {
            width: 100% !important;
            font-size: 11px !important;
            padding: 10px 8px !important;
        }

        .carousel-card {
            flex: 0 0 160px;
        }

        .carousel-card-title {
            font-size: 13px;
        }

        .carousel-card-subtitle {
            font-size: 11px;
        }

        .carousel-card-btn {
            font-size: 11px;
            padding: 6px 10px;
        }
    }

</style>

{% endblock content %}
